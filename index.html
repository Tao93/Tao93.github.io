<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/30/hello-world/" class="article-date">
  <time datetime="2018-08-30T08:01:39.308Z" itemprop="datePublished">2018-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/30/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/30/hello-world/" data-id="cjlga8n290002spwhda8y9ebc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android Touch 事件的传递与处理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/30/Android Touch 事件的传递与处理/" class="article-date">
  <time datetime="2018-08-30T06:59:39.237Z" itemprop="datePublished">2018-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、MotionEvent</p>
<p>MotionEvent 是 Android 系统中报告动作输入（如触摸屏幕，滚动球，鼠标）等事件的类。其中有整形数的 Action 和描述事件的各种浮点型坐标。MotionEvent 的 action 的最低一个字节，其取值我们常见的 ACTION_DOWN, MOVE, POINTER_DOWN, POINTER_UP, UP, CANCEL (后面可能简称为 DOWN 等等) 这些了。虽然我们可能会粗暴的使用下面这样的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">    <span class="keyword">case</span> MotionEvent.ActionDown:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是其实上面这样仅适用于单点触控场景，原因是 getAction() 方法返回的结果中，最低的1个字节才对应上面说的 ACTION_DOWN，而次最低一个字节则表示 PointerIndex (这个概念后面会提到)，对于单点触控场景，PointerIndex 始终为0，所以上面的代码才能跑通。更好的方式，其实是使用 getActionMasked() 方法，此处查看源码即可非常清晰。</p>
<p>对于一串触摸事件（指手接触到屏幕到手完全离开屏幕），用户第一个手指接触到屏幕时，触发 DOWN, 手指在屏幕上移动时，持续触发出很多 MOVE，第二个以上的手指触摸到屏幕是，触发 POINTER_DOWN，非最后一个离开屏幕的手指离开屏幕时触发 POINTER_UP, 最后一个手指离开屏幕时，触发 UP。</p>
<p>在一串触摸事件过程中，视图从 window detach 的话，或者 View 的 PFLAG_CANCEL_NEXT_UP_EVENT 标记位设置了时，或者 View 本来处理了一个 Down 事件但是接下来的 MOVE 等事件被 ViewGroup 拦截了，将会触发 CANCEL。当然，应该还有别的触发 CANCEL 事件的场景。下图是一串 Touch 事件的例子：</p>
<pre><code>Down → Move →...→ Move → PointerDown → Move →...→ PointerUp → Move →...→ Move → Up
</code></pre><p>MotionEvent 中有个 Pointer 的概念，Pointer 大致表示触摸到屏幕的各个手指。getPointerCount() 即为多点触控的点数。每个 pointer 都有一个 index (取值是0到getPointerCount()-1)和 id（最大是31，意味着一串触摸事件中，最多允许手指接触屏幕32次），前者在一串 Touch 事件中可能会变化，而后者保持不变，例如多点触控时，大拇指对应的 index 本来是0，后面可能变成了1了. getPointerId(int pointerIndex)和findPointerIndex(int pointerId)这两个方法是 index 和 id 间的一一映射。 那为什么要有 index 和 id 两个东西呢？</p>
<p>index 和 id 的区别。举个例子就清楚了。假设起始时，右手的食指，中指，无名指依次先后落在屏幕上，那么三个指头的 index 和 id 分别都是 0, 1, 2。此时抬起中指，那么食指的 index 和 id 不变，而无名指的 index 变成1，id 依然是2。即 index 总是 0, 1, 2,…, getPointerCount() - 1. 而 id 则可能大于 getPointerCount(), 另一面则是，pointer 的 id 在整个一串触摸事件中保持不变。</p>
<p>MotionEvent 的 getX() 与 getX(int pointerIndex), 前者等价于后者的 getX(0), getY 类似. getPointerIdBits() 返回一个类似于标志数的东西，其二进制从右向左数，第 i 位为1表示存在 id 是 i 的 pointer，此处应看源码。可以想见此结果的二进制形式中1的个数即为多点触控的点数。</p>
<p><img src="http://tao93.top/wp-content/uploads/2018/08/pointer_id_bits.png" alt="pointer_id_bits"></p>
<p>二、Touch 事件的生成</p>
<p>Touch 事件的根源是从硬件而来，而 ViewRootImpl$ViewPostImeInputStage#processPointerEvent 方法是一个比较合适的开始追踪 Touch 事件的起点，此处应看源码。事件如果没有被消费，最终可能将在 ViewRootImpl #finishInputEvent 中回收掉(这不是本文的重点)。Touch 事件的传递堆栈 (按调用的顺序排列)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ViewRootImpl$ViewPostImeInputStage#processPointerEvent</span><br><span class="line">View#dispatchPointerEvent</span><br><span class="line">DecorView#dispatchTouchEvent</span><br><span class="line">Activity#dispatchTouchEvent</span><br><span class="line">PhoneWindow#superDispatchTouchEvent</span><br><span class="line">DecorView#superDispatchTouchEvent</span><br><span class="line">ViewGroup#dispatchTouchEvent</span><br></pre></td></tr></table></figure>
<p>Touch 事件传递到了 ViewGroup 的 dispatchTouchEvent 方法后，就开始是本文要关注的焦点了，即一串 Touch 事件在 View 树上是如何传递和消费的。</p>
<p>三、传递和处理 Touch 事件</p>
<p>下面是事件传递和处理中最重要的 4 个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">View#dispatchTouchEvent，非 ViewGroup 的 View 接受 Touch 事件的方法，我们一般不重载它。</span><br><span class="line"></span><br><span class="line">View#onTouchEvent，View(含 ViewGroup)自己尝试去消费 Touch 事件，经常会被重载。</span><br><span class="line"></span><br><span class="line">ViewGroup#dispatchTouchEvent，重载了 View 的同名方法，作为 ViewGroup 接受 Touch 事件，此方法中包含「传递 Touch 事件给 child」和「尝试自己消费 Touch 事件」这样两个分支逻辑，一般不重载它。</span><br><span class="line"></span><br><span class="line">ViewGroup#onInterceptTouchEvent，ViewGroup 判断自己要不要拦截 Touch 事件的方法，拦截意味着自己尝试消费此事件，有时候被重载。</span><br></pre></td></tr></table></figure>
<p><strong>传递:</strong></p>
<p>在 View 树中，Touch 事件是由 parent view 传递给 child View (child view 也可能是 ViewGroup)的。在一串 touch 事件中打头的总是 DOWN 事件，parent view 通过调用 child view 的 dispatchTouchEvent方法把 DOWN 事件传递给 child view，这就给了 child 一个消费此事件的机会。child 的 dispatchTouchEvent 方法返回 true 的话，就表示 child 消费了 DOWN 事件，返回 false 就表示不消费。如果 child 消费了 Down 事件，那么最简单的情况就是后续的 move 等事件都会通过调用 child 的 dispatchTouchEvent 方法直接交给此 child，不管它的 dispatchTouchEvent 方法返回什么；如果 child 没有消费 DOWN 事件，那么单点触控情形下，后续的 move 等事件与此 child 再也无缘了。</p>
<p><strong>消费：</strong></p>
<p>View(包括 ViewGroup) 消费 Touch 事件，在代码上等价于调用当前类的 onTouchEvent 方法。然后 ouTouchEvent 的返回结果作为是否消费了此事件的依据。</p>
<p><strong>拦截：</strong></p>
<p>拦截是指 ViewGroup 有机会在把 touch 事件 dispatch 给 child 前，通过调用自己的 onInterceptTouchEvent 来判断要不要把 touch 事件截下来给自己尝试消费。对于 DOWN 事件，onInterceptTouchEvent 总是会被调用；对于其他事件，child 有机会在 parent 的onInterceptTouchEvent 被调用之前，请求 parent 不要拦截，这个请求就是通过 child 调用 parent 的 requestDisallowInterceptTouchEvent 方法来实现的。</p>
<p><strong>DOWN 事件：</strong></p>
<p>DOWN 事件是一串 touch 事件的第一个事件，在 ViewGroup 的 dispatchTouchEvent 方法中，接到此事件时，首先会做一些清除工作，然后检查自己要不要拦截此事件和是不是要转为 CANCEL 事件。如果不拦截且不转为 CANCEL，那么挨个检查 child，在恰当的时候调用 child 的 dispatchTouchEvent 来看有没有 child 会消费此事件。</p>
<p>上面 4 段话，用伪代码来表示，大概就是下面这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewGroup</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted; <span class="comment">// 拦截即不把事件传给 child </span></span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>; <span class="comment">// View group 是否消费了事件 </span></span><br><span class="line">        <span class="keyword">if</span> (is DOWN || child ever comsumed previous event) &#123; </span><br><span class="line">            <span class="keyword">if</span> (! disallowIntercept) &#123; <span class="comment">// PS: 对于 DOWN 其实 disallowIntercept 一定是 false </span></span><br><span class="line">                intercepted = onInterceptTouchEvent(event); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                intercepted = <span class="keyword">false</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            intercepted = <span class="keyword">true</span>; </span><br><span class="line">        &#125; <span class="keyword">if</span> (! canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">            <span class="keyword">for</span> (View child : all children) &#123;</span><br><span class="line">                <span class="keyword">if</span> (! child able to consume event) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>; </span><br><span class="line">                &#125; <span class="keyword">if</span> (dispatchTransformedTouchEvent(event, child)) &#123; </span><br><span class="line">                    <span class="comment">// 做一些记录工作，然后 break </span></span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// previous event 指这一串 touch 事件中在 event 前面的那些 </span></span><br><span class="line">        <span class="keyword">if</span> (no child ever consumed previous event) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTransformedTouchEvent(event); </span><br><span class="line">            <span class="comment">// 尝试自行消费 event </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">// 其实非 down 事件才能走到这个 else 分支 </span></span><br><span class="line">            <span class="keyword">for</span> (child : children who has consumed previous event) &#123;</span><br><span class="line">                <span class="keyword">if</span> (child.dispatchTouchEvent(event) </span><br><span class="line">                    handled = <span class="keyword">true</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> handled; </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>; </span><br><span class="line">        <span class="keyword">if</span> (mOnTouchListener != <span class="keyword">null</span> &amp;&amp; isEnabled &amp;&amp; mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123; </span><br><span class="line">            result = <span class="keyword">true</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// onTouch 优于 onTouchEvent 来代表 View 尝试消费 event </span></span><br><span class="line">        <span class="keyword">if</span> (! result &amp;&amp; onTouchEvent(event)) &#123; </span><br><span class="line">            result = <span class="keyword">true</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> result; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isEnabled()) &#123;</span><br><span class="line">            <span class="keyword">return</span> isClickable() || isLongClickable(); </span><br><span class="line">        &#125; <span class="keyword">if</span> (isClickable || isLongClickable) &#123; </span><br><span class="line">            ...</span><br><span class="line">            retrun <span class="keyword">true</span>; </span><br><span class="line">        &#125; retrun <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>各个类和方法的角色描述如下：</p>
<blockquote>
<p>ViewGroup#dispatchTouchEvent，代表 ViewGroup 接受事件，处理拦截逻辑，尝试分发事件给 child，调用 View#dispatchTouchEvent来尝试自行消费 Touch 事件。返回值表示自己这颗子树有没有消费事件。</p>
</blockquote>
<blockquote>
<p>View#dispatchTouchEvent 代表非 ViewGroup 的 View 接受事件，调用真正尝试消费事件的代码（onTouchEvent 或者 onTouch 之类的方法）。返回值表示自己有没有消费事件。</p>
</blockquote>
<blockquote>
<p>ViewGroup#onInterceptTouchEvent，返回值表示 ViewGroup 要不要拦截事件。</p>
</blockquote>
<blockquote>
<p>ViewGroup#requestDisallowIntercept，被 child 来调用，表示请求 parent 不要拦截，这个请求仅在非 DOWN 事件有效，且会递归向上调用所有 parent 的同名方法。</p>
</blockquote>
<blockquote>
<p>TouchTarget 类，此类包含消费过 Touch 事件的 child 和它消费过哪些 pointer 的事件这些信息，TouchTarget 如下图所示。在 ViewGroup 中，存有一个 TouchTarget 链表，遍历此链表，即可知道一个 pointer 是否已有事件被某个 child 处理过。</p>
</blockquote>
<p>以上的介绍，其实是省略了不少信息，真正的事件分发过程，要更复杂不少，下面是我尝试画的一张流程图 (把图和源码对照着理解可能会有些帮助)：</p>
<p><img src="http://tao93.top/wp-content/uploads/2018/08/dispatch_procedure.png" alt=""></p>
<p>对于上图，有一些需要解释的地方：</p>
<ol>
<li><p>TouchTarget 持有一个 child View，和此 child View 曾消费过 Down 或者 pointerDown 事件的那些 Pointer 的 id，这些 pointer id 是以 id bits 的形式存储为一个整数的。</p>
</li>
<li><p>TouchTarget 链表的头结点是由 mFirstTouchTarget 引用的。在一串事件结束(处理完 UP)后，正常情况链表应该清空，在一串 Touch 事件到来前(处理 Down 前)也会清空，算是补刀。</p>
</li>
<li><p>链表的意义是，存储 child 曾经消费过某些 pointer 的 Down 或者 PointerDown 事件这种信息。当一个 Pointer 结束了（手指头离开屏幕），那么所有消费过它的 Down 或者 PointerDown 事件的 TouchTarget 都需要移除掉它的 id，事实上，这一串 touch 事件中再也不会有这个 id 了；如果一个 TouchTarget 的 pointer id移除光了，那么意味着此 TouchTarget 持有的 child 没有消费过任意(现存)的 pointer 的 Down 或者 PointerDown，于是可以把此 TouchTarget 从链表移除了。</p>
</li>
<li><p>每次一个 Down 或者 PointerDown 事件 ev 到来时，对于 ViewGroup 的每个 child x，若 ev 的坐标落在 x 的范围内(否则就 continue，考虑下一个 child)，进一步「如果 x 在链表中(说明 x 消费过 Down 或者 pointerDown 事件)，那么 x 就是要被分发的 child；否则如果 x.dispatchTouchEvent(ev) 返回 true 了，那么 x 同样是要被分发的 child，虽然此时分发已经结束了」。</p>
</li>
<li><p>每个 move 事件 ev 到来时，链表为空的话，显然没有 child 消费过 down 或者 pointerDown，那么直接让 viewGroup 处理 ev 就好了。链表不为空的话，对于链表的每个 TouchTarget t 持有的 child x：如果转成了 cancel 事件，那么向 x 分发一个 cancel 事件，另外把 t 从链表移除(移除的原因是，例如 x 正在 detaching，所以才引发 cancel，那么当然需要把持有 x 的 t 移除)，然后 over，即 move 事件丢失了；没转成 cancel，那就检查 t 的 idBits 中有没有 ev 的任意一个 pointer 的 id，有则把 ev 交给 x，没有则 continue。</p>
</li>
</ol>
<p>四、源码分析</p>
<p>下面粘贴一大段加上了我的理解作为注释的源码，代码真的很长很长，这还仅仅是 ViewGroup#dispatchTouchEvent 这一个方法的代码。关于多点触控的处理逻辑，我也没有彻底明白，sigh。。。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 若当前类上面覆盖了其他window, 且 ev 的flag已标记过滤「覆盖」情况下的事件，则直接跳过</span></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line">        <span class="comment">// Handle an initial down.</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">            <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class="line">            <span class="comment">// due to an app switch, ANR, or some other state change.</span></span><br><span class="line">            cancelAndClearTouchTargets(ev); <span class="comment">//如链表非空, 向其中所有 touchTarget 持有的 child 发 cancel 事件, 并清空链表</span></span><br><span class="line">            resetTouchState(); <span class="comment">// reset 此 ViewGroup 的 CANCEL_NEXT_UP 和 DISALLOW_INTERCEPT</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check for interception.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">        <span class="comment">// down 事件, 或者链表不空(意思是曾有 down 事件被某个 child 消费过)时, 考虑拦截</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 前面的 resetTouchState() 使得 disallowIntercept 必定是 false</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 其他情况, 不用把事件交给任何 child, 所以直接赋值 intercepted = true</span></span><br><span class="line">            <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">            <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">            intercepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check for cancelation.</span></span><br><span class="line">        <span class="comment">// 此 ViewGroup 有 cancel_next_up 标志, 那么就转成 cancel 事件</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>)</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line">        <span class="comment">// Update list of touch targets for pointer down, if needed.</span></span><br><span class="line">        <span class="comment">// API 11 以上, split 必为 true</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="number">0</span>;</span><br><span class="line">        TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 标记 down/pointerDown 被某个 child 消费</span></span><br><span class="line">        <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">            <span class="comment">// down/pointerDown 才寻求 child 来接盘, 其余类型的事件都是谁消费了 down/pointerDown 就交给谁</span></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                <span class="comment">// 得到 ev 当前 action 所所属的 pointer 的 index</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// always 0 for down</span></span><br><span class="line">                <span class="comment">// idBitsToAssign 包含一个 id, 即 ev 所属 pointer 的 id</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                        : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line">                <span class="comment">// Clean up earlier touch targets for this pointer id in case they</span></span><br><span class="line">                <span class="comment">// have become out of sync.</span></span><br><span class="line">                <span class="comment">// down/pointerDown 意味着新的 pointer, 清除一下链表中和新 pointer 的 id 之间的瓜葛</span></span><br><span class="line">                removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line">                    <span class="comment">// Find a child that can receive the event.</span></span><br><span class="line">                    <span class="comment">// Scan children from front to back.</span></span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">                    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                                childrenCount, i, customOrder);</span><br><span class="line">                        <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                                preorderedList, children, childIndex);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 不能接受或者是 ev 坐标不在 child 内部则 continue</span></span><br><span class="line">                        <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                                || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        newTouchTarget = getTouchTarget(child);</span><br><span class="line">                        <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 说明 ev 落在 child 内部且 child 以前响应过 down/pointerDown, 那么由 child 来接盘, 故 break</span></span><br><span class="line">                            <span class="comment">// 如果 ev 是 Down 事件, 列表尚空, 则走不到这里来</span></span><br><span class="line">                            <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">                            <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">                            <span class="comment">// child 所属 TouchTarget 可能增加一个 pointer id</span></span><br><span class="line">                            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        resetCancelNextUpFlag(child);</span><br><span class="line">                        <span class="comment">// 尝试让 child 消费 ev</span></span><br><span class="line">                        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                            <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">                            mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                            <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                        mLastTouchDownIndex = j;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                mLastTouchDownIndex = childIndex;</span><br><span class="line">                            &#125;</span><br><span class="line">                            mLastTouchDownX = ev.getX();</span><br><span class="line">                            mLastTouchDownY = ev.getY();</span><br><span class="line">                            <span class="comment">// 消费成功的话, 用 child 新建 TouchTarget, 插到链表头部,</span></span><br><span class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                            alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// The accessibility focus didn't handle the event, so clear</span></span><br><span class="line">                        <span class="comment">// the flag and do a normal dispatch to all children.</span></span><br><span class="line">                        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 没找到接盘的, 且链表不空(意思是有 Down/pointerDown 被 child View 消费过)</span></span><br><span class="line">                    <span class="comment">// Did not find a child to receive the event.</span></span><br><span class="line">                    <span class="comment">// Assign the pointer to the least recently added target.</span></span><br><span class="line">                    <span class="comment">// 强行让链表末尾节点持有的 child 来接盘</span></span><br><span class="line">                    newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                    <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        newTouchTarget = newTouchTarget.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Dispatch to touch targets.</span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123; <span class="comment">// child view 压根没有消费过事件</span></span><br><span class="line">            <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">            <span class="comment">// view group 尝试自行消费</span></span><br><span class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                    TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Dispatch to touch targets, excluding the new touch target if we already</span></span><br><span class="line">            <span class="comment">// dispatched to it.  Cancel touch targets if necessary.</span></span><br><span class="line">            TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">            TouchTarget target = mFirstTouchTarget;</span><br><span class="line">            <span class="comment">// 遍历链表</span></span><br><span class="line">            <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                    <span class="comment">// ev 是 Down 或者 pointer Down 且它被 target 持有的 child 消费了</span></span><br><span class="line">                    handled = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 对于其他的 Touch target</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                            || intercepted;</span><br><span class="line">                    <span class="comment">// 发送 cancel 或者 ev 给 child, 或者啥也不做(target 的 idBits 没有 ev 中任意的 pointer 的 id)</span></span><br><span class="line">                    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                            target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                        handled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (cancelChild) &#123; <span class="comment">// 收到 cancel 后,child 就不该再收到事件了, 对应的 TouchTarget 也要移除</span></span><br><span class="line">                        <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            mFirstTouchTarget = next;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            predecessor.next = next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        target.recycle();</span><br><span class="line">                        target = next;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                predecessor = target;</span><br><span class="line">                target = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Update list of touch targets for pointer up or cancel, if needed.</span></span><br><span class="line">        <span class="keyword">if</span> (canceled</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">            resetTouchState(); <span class="comment">// up 事件后,这一串 Touch 事件就结束了, 清理链表等</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">            <span class="comment">// 某个 pointer 没了, 那么清空链表中和这个 pointer 的瓜葛</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> idBitsToRemove = <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">            removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!handled &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(ev, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>五、滑动冲突分析示例</p>
<p>在《安卓开发艺术探索》一书中讲 touch 事件的最后，讲了滑动冲突的解决方法。所谓滑动冲突最简单的情形就是一个水平滑动的 ScrollView 里面放一个竖直滑动的 listView，两者滑动方向不同，即为滑动冲突。对于这个情形，解决滑动冲突，其实就是在手指上下滑时吧 move 事件给 child（listView）处理，而手指左右滑动时给 parent 处理（ScrollView）即可。下面是书中的一种解决方式，使用上面讲的知识，我们可以透彻的分析这种解决方式。</p>
<p>下面是《安卓开发艺术探索》中提供的其中一种解决方法，我加入了比较详细的注释作为解释，在前面的基础上，这种解决方法的逻辑就很明确了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildView</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">view</span>.<span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        ViewParent parent = getParent();</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (event.getActionMasked()) &#123;</span><br><span class="line">                <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                    <span class="comment">// 此次请求其实在 Down 事件后的首个 Move 传至 parent 中时生效</span></span><br><span class="line">                    <span class="comment">// 若不请求，则将会发生拦截，后续事件都和 child 无缘，所以必须请求别拦截</span></span><br><span class="line">                    parent.requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                    <span class="comment">// 如果期望 parent 来处理，那么解除请求，则下一次 Move 事件时必定拦截，后续事件就全部交给 parent 了。</span></span><br><span class="line">                    <span class="comment">// 否则，什么也不做，即事件会继续源源不断的交给 child</span></span><br><span class="line">                    <span class="keyword">if</span> (parent should handle event)&#123;</span><br><span class="line">                        parent.requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentView</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Down 时，必然调此方法，此时不应拦截，否则 child 永远无法处理 move 事件</span></span><br><span class="line">        <span class="comment">// 其他事件时，若 child 请求不拦截，那么后面的事件都交给 child 了；否则，就会</span></span><br><span class="line">        <span class="comment">// 调用此方法，此方法这时返回 True 即表示拦截，那么会发一个 cancel 给 child，后续的事件就和 child 无缘了</span></span><br><span class="line">        <span class="keyword">return</span> ev.getActionMasked() != MotionEvent.ACTION_DOWN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，这篇长长的、并不完美的分析也就结束了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/30/Android Touch 事件的传递与处理/" data-id="cjlga8n300004spwhrvd386nq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android ImageView ScaleType" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/30/Android ImageView ScaleType/" class="article-date">
  <time datetime="2018-08-30T06:57:52.497Z" itemprop="datePublished">2018-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我经常记不住 Android 中 ImageView 的各种 ScaleType 的含义，看文档一时也确定不了，所以干脆把所有 ScaleType 挨个尝试了一遍，然后清楚的记录下来，以备今后查阅。</p>
<p><strong>CEMTER</strong></p>
<p>图片大小不做任何缩放，仅仅把图片中心和视图中心重合。可能图片小于视图框，也可能反过来。</p>
<p><strong>CENTER_CROP</strong></p>
<p>将图片放大或者缩小，直到视图框被布满，且图片的两个边缘或者所有边缘和视图框的对应边缘重合。</p>
<p><strong>CENTER_INSIDE</strong></p>
<p>可能将图片缩小，但是不会放大，目标是把图片放置在视图框之内，不能有露在外面的，图片中心和视图框中心重合。</p>
<p><strong>FIT_CENTER</strong></p>
<p>图片可能放大也可能缩小，目标是让图片在是图框内部，且图片占据最大的可用空间，图片中心和视图框中心重合。</p>
<p><strong>FIT_START</strong></p>
<p>类似于 fit_center 只不过图片中心可能和视图框中心不重合，而是图片处在视图框的上侧或者左侧。</p>
<p><strong>FIT_END</strong></p>
<p>类似于 fit_center 只不过图片中心可能和视图框中心不重合，而是图片处在视图框的下侧或者右侧。</p>
<p><strong>FIT_XY</strong></p>
<p>图片可能会被拉伸，效果是图片的四个边缘和视图框的四个边缘无条件重合。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/30/Android ImageView ScaleType/" data-id="cjlga8n220000spwhbn80t8c5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL 数据库支持 emoji 表情字符" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/30/MySQL 数据库支持 emoji 表情字符/" class="article-date">
  <time datetime="2018-08-30T06:51:56.379Z" itemprop="datePublished">2018-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>兴冲冲的整个博客，死皮赖脸的叫几个同学来评论，结果评论中输入的 emoji 表情最后会变成问号，试想别人评论「写的真棒 😄」结果变成了「写的真棒 ？」，这是何其的尴尬。</p>
<p>继续回到这个问题本身。我登录到数据库一查，发现数据库中存的评论文本就是个问号，这说明 emoji 表情存到数据库的过程出问题了。赶紧一查，发现网上还是很容易找到了解决方法。问题的原因是 MySQL 存储文本时默认的 UTF-8 仅支持 3 个字节编码，而 emoji 是 4 字节编码的，所以存储过程出问题了。所以需要将 charset 设置为 UTF-8 的超集 UTF-8mb4，虽然我也不知道这个 UTF-8mb4 是何方神圣。</p>
<p>首先，需要在配置文件 my.cnf (在我的机器上这个文件路径是 /etc/my.cnf) 中添加一下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">character-set-client-handshake = FALSE</span><br><span class="line">character-set-server = utf8mb4</span><br><span class="line">collation-server = utf8mb4_unicode_ci</span><br><span class="line">init_connect=’SET NAMES utf8mb4&apos;</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8mb4</span><br></pre></td></tr></table></figure>
<p>然后，需要修改已有库、表、字段的 charset。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 修改库的 </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> &lt;database_name&gt; <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8mb4 <span class="keyword">COLLATE</span> = utf8mb4_unicode_ci; </span><br><span class="line"></span><br><span class="line"># 修改表的 </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;table_name&gt; <span class="keyword">CONVERT</span> <span class="keyword">TO</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci; </span><br><span class="line"></span><br><span class="line"># 修改字段的 </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;table_name&gt; <span class="keyword">CHANGE</span> &lt;column_name&gt; &lt;column_name&gt; &lt;original_column_type&gt; <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>
<p>最后重新启动 MySQL 服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/mysql stop sudo /etc/init.d/mysql start</span><br></pre></td></tr></table></figure>
<p>另外，mysqldump 时，也需要进行额外指定 char set：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -default-character-set-utf8mb4 -u &lt;db_user_name&gt; -p --databases &lt;db_name&gt; --lock-all-tables &gt; &lt;file_name&gt;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/30/MySQL 数据库支持 emoji 表情字符/" data-id="cjlga8n260001spwhagec6c4p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-常用的 Bash 命令总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/30/常用的 Bash 命令总结/" class="article-date">
  <time datetime="2018-08-30T06:22:22.266Z" itemprop="datePublished">2018-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这篇记录是我看 <a href="http://linuxcommand.org/tlcl.php" target="_blank" rel="noopener">The Linux Command Line</a> 后为了总结而写的，目的是便于自己随时查阅。The Linux Command Line 是我相当喜欢的一本电子书，它是一本值得一页一页看下去的书。</p>
<p><strong>cp</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅复制目标目录不存在或者存在但是更旧的的项。 </span></span><br><span class="line">cp -u </span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 file2 已经存在, file2 的内容会被 file1 的内容重写。如果 file2 不存在，则会创建它。 </span></span><br><span class="line">cp file1 file2 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果目录 dir2 不存在，创建目录 dir2，操作完成后，目录 dir2 中的内容和 dir1 中的一样。如果目录 dir2 存在，则目录 dir1 和其中的内容将会被复制到 dir2 中。 </span></span><br><span class="line">cp -r dir1 dir2</span><br></pre></td></tr></table></figure>
<p><strong>mv</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅移动目标目录不存在或者存在但是更旧的的项。 </span></span><br><span class="line">mv -u </span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果目录 dir2 不存在，创建目录 dir2，并且移动目录 dir1 的内容到目录 dir2 中，同时删除目录 dir1。如果目录 dir2 存在，移动目录 dir1( 它的内容)到目录 dir2 中。 </span></span><br><span class="line">mv dir1 dir2</span><br></pre></td></tr></table></figure>
<p><strong>rm</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 警惕不小心写出 rm * .html 这样的命令，这会删除当前目录的所有文件。</span><br></pre></td></tr></table></figure>
<p><strong>命令的4中形式</strong></p>
<ol>
<li>executable file, 可以是二进制的，也可以是文本形式的脚本；</li>
<li>builtins, 即 /bin 下面的 [, echo, kill, pwd, test 和 /usr/bin 下面的 alias, bg, cd, command, false, fc, fg, getopts, hash, jobs, printf, read, true, type, ulimit, umask, unalias, wait, which；</li>
<li>shell 函数</li>
<li>alias 定义的别名</li>
</ol>
<p><strong>type</strong></p>
<p>type是一个极其有用的命令，能立马找到当前环境能用的命令是源自哪里，是什么类型的。示例：</p>
<blockquote>
<p>➜  ~ type Python3<br>Python3 is /Users/didi/.bin/Python3<br>➜  ~ ls -l /Users/didi/.bin/Python3<br>lrwxr-xr-x  1 didi  staff  22  4 25 10:06 /Users/didi/.bin/Python3 -&gt; /usr/local/bin/python3<br>➜  ~ type [<br>[ is a shell builtin<br>➜  ~ type ls<br>ls is an alias for ls -G</p>
</blockquote>
<p><strong>where</strong></p>
<p>where命令的有用之处是它可以列出所有出现的地方，比如电脑里面有两个 git 可执行文件，那么 where git 可以把它们统统列出来。</p>
<p><strong>man 手册的章节含义</strong></p>
<ol>
<li>用户命令</li>
<li>程序接口内核系统调用</li>
<li>库函数程序接口</li>
<li>特殊文件，比如说设备结点和驱动程序</li>
<li>文件格式</li>
<li>游戏娱乐，如屏幕保护程序</li>
<li>其他方面</li>
<li>系统管理员命令</li>
</ol>
<p><strong>&gt; file_name</strong></p>
<p>巧妙的使用重定向，可以将文本文件的内容清空，也可以新建一个空文件。</p>
<p><strong>重定向的常见用法</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 覆盖型重定向 stdout，可以省略那个 1 </span></span><br><span class="line">ls ~ 1&gt; out.txt </span><br><span class="line"></span><br><span class="line"><span class="comment"># 追加性重定向 stdout，可以省略那个 1 </span></span><br><span class="line">ls ~ 1&gt;&gt; out.txt </span><br><span class="line"></span><br><span class="line"><span class="comment"># 覆盖型重定向 stderr </span></span><br><span class="line">ls ~ 2&gt; out.txt </span><br><span class="line"></span><br><span class="line"><span class="comment"># 追加性重定向 stdout </span></span><br><span class="line">ls ~ 2&gt;&gt; out.txt</span><br></pre></td></tr></table></figure>
<p><strong>/dev/null</strong></p>
<p>随意放东西进去的垃圾箱</p>
<p><strong>花括号展开</strong></p>
<p>echo Front-{A..D}–Back 将会输出四项内容，即 {A..D} 表示从 A 到 D 一共四个情况。</p>
<p><strong>将命令执行结果展开</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只需要把命令放在 $() 里面即可，旧版 shell 也使用把命令放在 `` 中间的方式 </span></span><br><span class="line"><span class="built_in">echo</span> $(ls)</span><br></pre></td></tr></table></figure>
<p><strong>引号</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 双引号中，参数展开，算术表达式展开，和命令替换仍然有效，比如 </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$USER</span> <span class="variable">$((2+2)</span>) <span class="variable">$(cal)</span>"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 单引号中，所有展开都无效</span></span><br></pre></td></tr></table></figure>
<p><strong>命令行移动光标</strong></p>
<blockquote>
<p>ctrl a # 移动到行首</p>
<p>ctrl e # 移动到行末</p>
<p>alt &lt;- # 左移一个 word</p>
<p>alt -&gt; # 右移一个 word</p>
<p>ctrl u # 剪切整行内容</p>
<p>ctrl k # 剪切光标后面的内容</p>
<p>ctrl y # 粘贴</p>
</blockquote>
<p><strong>管理进程</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出终端相关进程</span></span><br><span class="line">ps </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有进程</span></span><br><span class="line">ps x </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有进程的详细信息</span></span><br><span class="line">ps aux </span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示从终端启动的后台进程</span></span><br><span class="line"><span class="built_in">jobs</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 让指定序号的从终端启动的进程返回到前台</span></span><br><span class="line"><span class="built_in">fg</span> %JOB_SPEC </span><br><span class="line"></span><br><span class="line"><span class="comment"># 让指定序号的从终端启动的进程返回到后台</span></span><br><span class="line"><span class="built_in">bg</span> %JOB_SPEC </span><br><span class="line"></span><br><span class="line"><span class="comment"># 给进程发送信号，最常见的信号是：</span></span><br><span class="line"><span class="built_in">kill</span> -SIG_NUM PID </span><br><span class="line">    1  HUP  挂起</span><br><span class="line">    2  INT  中断，和 ctrl c 的作用一样</span><br><span class="line">    9  KILL 杀死，这个信号并不会发给进程号是 PID 的进程，而是立即强制停止此进程，被杀进程就没有机会保存数据</span><br><span class="line">    15 TERM <span class="built_in">kill</span> 命令的默认信号，终止进程，被中止的进程有机会保存数据</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/30/常用的 Bash 命令总结/" data-id="cjlga8n2b0003spwh83s5bb38" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/08/30/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2018/08/30/Android Touch 事件的传递与处理/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/08/30/Android ImageView ScaleType/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/08/30/MySQL 数据库支持 emoji 表情字符/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/08/30/常用的 Bash 命令总结/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>macOS 编译 Android 9 源码</title>
      <link href="/2018/09/06/macOS%20%E4%B8%8B%E7%BC%96%E8%AF%91%20Android%209%20%E6%BA%90%E7%A0%81/"/>
      <url>/2018/09/06/macOS%20%E4%B8%8B%E7%BC%96%E8%AF%91%20Android%209%20%E6%BA%90%E7%A0%81/</url>
      <content type="html"><![CDATA[<h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mstr</span>://?url=https<span class="number">%3</span>A<span class="number">%2</span>F<span class="number">%2</span>Fenv-108450.customer.cloud.microstrategy.com<span class="number">%3</span>A443<span class="number">%2</span>FMicroStrategyMobile<span class="number">%2</span>Fservlet<span class="number">%2</span>FtaskProc<span class="number">%3</span>FtaskId<span class="number">%3</span>DgetMobileConfiguration<span class="number">%26</span>taskEnv<span class="number">%3</span>Dxml<span class="number">%26</span>taskContentType<span class="number">%3</span>Dxmlanf<span class="number">%26</span>configurationID<span class="number">%3</span>Ded898ae5-739f-4f8a-960a-1571a8be575b&amp;authMode=1&amp;dt=2</span><br></pre></td></tr></table></figure><h4 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h4><pre><code>macOS High Sierra 10.13.6 with 16GB RAMXCode 9.4.1Oracle JDK 1.8.0_181</code></pre><p>大约 1 个月之前，Google 推出了 Android Pie 正式版，我也用 Pixel XL 设备第一时间更新到了 Pie，结果发现和 Oreo 相比变化不大。此外，我也想到 Google 应该早就在 AOSP 创建了 Android Pie 的代码分支，正好我到刚到 Microstrategy 来上班，换了新的 MacBook，是时候再次用 MacBook 编译一次 AOSP 源码了。</p><p>首先我查看了手上的 2017 款 MacBook 15寸，发现这居然是 500GB 磁盘的，这令我十分惊喜，这意味着这台机器编译 Android 源码时磁盘空间将会绰绰有余。</p><h4 id="获取源代码"><a href="#获取源代码" class="headerlink" title="获取源代码"></a>获取源代码</h4><p>可从国内镜像先下载到一个压缩包，<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/aosp" target="_blank" rel="noopener">USTC Mirror</a> 和 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/" target="_blank" rel="noopener">Tuna</a> 都可选择，以下以 Tuna 为例。</p><p>首先从 <a href="https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly" target="_blank" rel="noopener">这里</a> 下载 aosp-latest.tar 文件和对应的 MD5 文件。这个 tar 文件中是近期的整个 AOSP 项目的压缩包。下载可以使用 wget 加 -c 命令，这样即使下载意外失败，也可以接上中断的地方继续下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># download aosp-latest.tar file, with -c option</span></span><br><span class="line">wget -c https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar</span><br></pre></td></tr></table></figure><p>下载完成后，可以通过以下命令获取 md5 值，检查和下载到的 aosp-latest.tar.md5 文件中的值是否一致：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get it's md5 value then check the value</span></span><br><span class="line">md5 aosp-latest.tar</span><br></pre></td></tr></table></figure><p>另一个令人惊喜的事，最近的 aosp 体积居然减小了，之前几个月 aosp 体积那是一路蹭蹭蹭往上涨，涨到了 40 多 GB：</p><p><img src="http://tao93.top/images/2018/09/06/1536224194.png" alt=""></p><p>接下来，按照之前我的 post <a href="http://tao93.top/2018/09/01/macOS%20系统编译%20Android%208.1.0%20源码全过程/">macOS 系统编译 Android 8.1.0 源码全过程</a> 中的描述，建立 sparse image 并挂载，然后将 aosp-latest.tar 解压到 sparse image 中。我在 sparse image 中建立了一个 aosp 目录，然后把 aosp-latest.tar 解压到了 aosp 目录中，此时 aosp 目录中仅有一个 .repo 目录。接下来我们来把最新的 Android Pie 分支的代码 checkout。</p><p>另外，要先知道我们需要哪个分支，在 <a href="https://source.android.com/setup/start/build-numbers" target="_blank" rel="noopener">这里</a> 可以看到所有代码分支与代号。在这个网页如果显示为中文，就拉到最底部在左下角把语言换成英文，因为英文才有最新的 Android Pie 相关信息。如下图所示，根据自己想要用于什么设备来选择分支，比如如果是 Pixel 2 设备那么最新的分支就是 android-9.0.0_r6，而不能使 android-9.0.0_r7 和 android-9.0.0_r8，我当时用的是 android-9.0.0_r2</p><p><img src="http://tao93.top/images/2018/09/06/1536224982.png" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prepare repo</span></span><br><span class="line">mkdir ~/bin</span><br><span class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$&#123;HOME&#125;</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> aosp</span><br><span class="line"></span><br><span class="line"><span class="comment"># init with specific branch android-9.0.0_r2, use other branch as you want</span></span><br><span class="line">repo init repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-9.0.0_r2</span><br></pre></td></tr></table></figure><p>接下来就可以 repo sync 了，可以直接执行此命令，也可以像我之前 post 一样写一个 sync 脚本来执行。</p><p>有于我们下载了最新的 aosp-latest.tar，所以 sync 的过程还是比较快的，我当时应该 30 来分钟就 sync 完成了。</p><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>以往编译 Android 源码时，总是会出现各种各样的错误，但是这次 Android Pie 的源码编译异常顺利，没有任何错误，不知道是不是 Google 做了改进和优化。</p><p>首先下载 XCode 安装，然后进入 aosp 根目录，就可以编译了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># clear build generated files</span></span><br><span class="line">make clobber</span><br><span class="line"></span><br><span class="line"><span class="comment"># import a build script</span></span><br><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># select build target </span></span><br><span class="line">lunch</span><br><span class="line"></span><br><span class="line"><span class="comment"># start build</span></span><br><span class="line">make -j8</span><br></pre></td></tr></table></figure><p>非常顺利，上次我选择 aosp_marlin-userdebug 用了 3 个半小时就成功编译了，简直令人感动。相比起来，之前的 Android 源码编译会出现各种各样的错误，让人非常抓狂。</p><p>因为我手里的 Pixel XL 已经安装了 factory Android system，里面有我很多资料和数据了，另外 userdebug 类型的 Android 是没有 Google 服务的，并且连 Google Photos、Camera、Gmail 等应用全都没有，所以我就没再把编译出来的 userdebug 类型系统安装到手机中。于是，我今天选择 aosp_x86_64-eng 重新编译了一遍，这个 aosp_x86_64-eng 适用于在 x86 电脑上运行模拟器 (没有手机就只好现在电脑上用模拟器试试了)。这一次用了 4 个多小时完成编译，同样非常顺利：</p><p><img src="http://tao93.top/images/2018/09/07/1536304013.png" alt=""></p><p>编译完成后，直接运行 emulator 命令即可运行模拟器。需要注意，这个 emulator 命令是运行 lunch 命令而添加的，也就是如果退出了电脑的 terminal，然后再进入 aosp 根目录，需要重新运行 source build/envsetup.sh 和 lunch 然后才能运行 emulator。以下是模拟器运行的截图：</p><p><img src="http://tao93.top/images/2018/09/07/1536305206.png" alt=""></p><p>上面 3 张截图中，左边两张截图可以看到系统是很简陋的，Google 的许多应用都没有，连 Google service 也没有。最有一张截图，显示了 Android 版本号是 9，另外最底部的 Build Number 显示了这是 aosp_x86_64-eng 类型的构建，PPR1.180610.010 是 Build 代号，在 <a href="https://source.android.com/setup/start/build-numbers" target="_blank" rel="noopener">这里</a> 可以看到，而 20180907.105244 则是构建时间。</p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> macOS </tag>
            
            <tag> AOSP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>targetSdkVersion 杂谈</title>
      <link href="/2018/09/03/targetSdkVersion%20%E6%9D%82/"/>
      <url>/2018/09/03/targetSdkVersion%20%E6%9D%82/</url>
      <content type="html"><![CDATA[<p>很久没有写新的博客了，原因是这一个多月以来都没想到什么合适的主题，今天就来杂谈一下 targetSdkVersion 相关的东西吧。</p><p>在我工作的第一年里，其实我并不知道 targetSdkVersion 有什么含义，查资料，看到的是类似于「代表应用针对某个 api level 完成适配了」这样的描述，这样的描述其实让我摸不着头脑。后来，我把一个小应用项目的 targetSdkVersion 升高到 api 27，这个过程才让我对 targetSdkVersion 理解比较到位了。而这时候，我发现 targetSdkVersion 的的确确如我先前查到的资料所言，表示针对某个 api level 完成适配了，这个信息是会传递给 android 系统的，android 系统依据这一信息来对应用做区别对待。</p><p>首先，需要明确 Android 系统在大版本更新时，总会加入一些新的 feature，而这些新 feature 可能会让老的应用无法完美兼容。典型的例子是 api 23 新增的运行时动态申请权限机制。在 api 23 以上的 android 系统中，系统期待代码先申请权限 (或者检查权限是已有的) 后才运行需要权限的代码 (例如拍照)。但是老应用的代码，则是只需要在 manifest 文件中申请拍照权限，就可以直接执行拍照的代码。所以，targetSdkVersion 的作用就是，如果 targetSdkVersion 大于等于 23，那么代码必须按新机制来 (即先申请权限，然后才能执行需要权限的代码)，否则，android 系统就认为这是个没有针对 api 23 进行适配的老应用 (比如可能是一个 2012 年就停止更新的应用）。对这种老应用，android 系统需要兼容，兼容的方式就是，这种应用一经安装，就自动获得了所有 manifest 中申明的权限，这样它就能在新系统中正常运行。</p><p>在新系统 (api 23 及以上) 中，对于上述的老应用，安装时会列出所有权限，告诉用户这个应用一经安装就有了下面的权限 (如同老系统安装所有应用时一样)。这就是系统的兼容机制。新系统中安装的这样的老应用后，我们在应用详情中可以看到它自动有了所有权限，可是新系统是可以手动关闭某个应用的权限的，如果我们关闭这个老应用的某个权限，会怎么样呢？如下图所示：</p><p><img src="http://tao93.top/images/2018/09/03/1535985225.png" alt=""></p><p>系统会提示用户，关掉权限的话应用可能无法正常运转。这是对的，因为假设老应用中有直接执行拍照逻辑的代码，拍照权限现在被用户手动关闭，那么执行到这样的代码时就会崩溃 (without permission)！</p><p>问题是，许多应用明明一直在更新，但是为了尽量获取到各种权限，会故意将 targetSdkVersion 停留在 22 及以下，这样用户一经安装，这样的应用就自动有了它想要的任何权限，例如 Android 版手机 QQ 现在的 targetSdkVersion 依然是 17：</p><p><img src="http://tao93.top/images/2018/09/03/1535985675.png" alt=""></p><p>对于这样的比较无赖的应用，其实可以放心把不想授予的权限关闭掉，它是不会崩溃的，因为其代码中其实已经做了权限检查，毕竟它一直在更新和维护。另外，对于这种现象，Google 也有措施，今年谷歌声明了对在 Google Play 更新的应用和上架的新应用都在今年必须将 targetSdkVersion 升至 27 (步子有点大)。虽然 Google Play 对国内还有点鞭长莫及，不过这一倡导应该还是会让许多大厂的应用更快的提高 targetSdkVersion。</p><p>另外，假如用户本来安装了 targetSdkVersion 为 22 的老应用，且老应用有所有想要的权限，此时如果更新到 targetSdkVersion 为 23 的新版本应用，那么新应用将「继承」所有的权限。反过来，新版本的应用的 targetSdkVersion 是不能比已安装的老版本应用还更低的，因为这不光兼容起来很麻烦，而且于情于理都不应该。 </p><p>动态申请权限大概算是最典型的一个无法完美兼容的 feature 了，除此之外，还有 api 26 引入的 adaptive icon 这个 feature。adaptive icon 使得应用可以根据 launcher 的偏好，显示圆形、圆角方形、正方形等各种形状的图标。许多老应用是直接自己裁剪一个圆角方形的图标，这显然无法完美满足 adaptive icon，所以是不完美兼容。targetSdkVersion 为 26 及以上的应用，应该且需要将 launcher icon 分为 foreground 和 background 两层，foreground 是图标中心的若干元素，比如<a href="https://www.coolapk.com/apk/me.piebridge.brevent" target="_blank" rel="noopener">黑阈</a> 的 launcher icon 的 foreground 是下面这样一张图片：</p><p><img src="http://tao93.top/images/2018/09/03/1535986448.png" alt=""></p><p>这个图片绝大部分都是透明的，只有那 3 条弧线是灰白色的。这样一个 foreground 作为黑阈应用图标的中心元素。而 background 则是 #FF353535 这样一个纯色。事实上，黑阈的在新系统的图标是如下所示的 xml 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">adaptive-icon</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">background</span> <span class="attr">android:drawable</span>=<span class="string">"@color/ic_brevent_background"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreground</span> <span class="attr">android:drawable</span>=<span class="string">"@mipmap/ic_brevent_foreground"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">adaptive-icon</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样一个文件声明了 foreground 和 background。当时黑阈也是可能在 api 25 及以下的 android 系统运行的，这样的系统没有 adaptive icon 这个 feature，所以，当应用的 minSdkVersion 不到 26 时，应用中还需要为老系统准备图标资源。其实做法就是上述 xml 文件命名为 ic_launcher.xml 之类的名字，置于 drawable-anydpi-v26 这样的资源目录中，而其他用于老系统的图标资源 ic_launcher.png 文件置于 drawable-xdpi 等资源目录中，即可。</p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从阿里云服务器到个人博客</title>
      <link href="/2018/09/03/%E4%BB%8E%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%B0%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/09/03/%E4%BB%8E%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%B0%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>(友情提示，想看步骤的话，下面的前言可以跳过不看)</p><p>为什么我现在要买阿里云的 VPS (Virtual Private Server) 搞博客系统呢？我也说不上为什么，不过可以讲一下事情的经过。</p><p>2016年刚开始工作那会儿，从<a href="http://ewind.us/" target="_blank" rel="noopener">王译锋</a>那里知道了租 VPS、搭建某 socks、nginx 驱动 hexo 博客这样一套东西。当时觉得很新鲜，立马也买了搬瓦工的 VPS，然后一同瞎搞，算是搞成了一个 hexo 静态博客系统了，不过有点尴尬的小插曲，我把 hexo 安装在了 VPS 上面 ，然后把 Markdown 文件推到 VPS 上面，然后再 VPS 再用 hexo 生成静态页面的文件。。。 实际上更合适的是把 hexo 安装在本地，然后本地生成的页面文件推到 nginx 的 web root 目录中去。</p><p>后来嘛，搬瓦工，Vultr，Linode 阿里云我都试了个遍，发现除了阿里云意外，虽然都不贵，但是网速稳定性真的很捉急，有时候在终端 ssh 到服务器上面时，输入命令真的是一卡一卡的，这样的网速带来的科学上网体验只能用「能用」两个字来形容。直觉告诉我，可能部署在香港的 VPS 网速会比较快，因为香港离大陆近。我就开始找香港的 VPS 了，一番找呀找，中间也交了些学费，最后找到了一个叫枫叶主机的，速度挺不错，轻松达到 500 KB/S，就是贵了点，我就和某同事一起平摊费用了。这个枫叶主机我一口气买了一年的，不过中间依然因为某些原因而出现网速不稳定的情况。等到枫叶主机过期后，因为穷，我忽然想试试老早就听别人推荐的一个叫云梯的 VPN。这个云梯我曾经使用过，但是的速度确实还不错，哪想到我一口气买了一年的 VPN 后，发现用不了，整个云梯团队都跑路了！！！就留下个网站还在运行，不断的吸钱，真他们坑！吃了大亏的我，开始蹭大学同学的 VPS 的某 socks 服务，挺长时间都没再买过 VPS了，期间，我把静态博客放到了 github.io 页面。然而，自始至终，我其实没写几篇博客，真为自己的懒惰感到惭愧。</p><p>直到最近，再次看到珂神和王译锋的博客、掘金搞得风生水起，感叹自己没有能拿的出手的东西，所以就买阿里云 VPS → 注册域名 → 搭博客系统了，期待自己能多写一些有价值的东西，加油！</p><h3 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h3><h4 id="租阿里云-VPS"><a href="#租阿里云-VPS" class="headerlink" title="租阿里云 VPS"></a>租阿里云 VPS</h4><p>在阿里云官网，这个叫做「云服务器 ECS」，这个其实很简单了，花几百块钱就能租一年，我是 290 几块钱租的 1GB 内存、1Mbps 带宽、40GB 非 SSD 的香港 VPS。其实，对我们而言最敏感的性能指标就是内存和带宽了，硬盘一般是不会用光的，CPU 性能也没多大影响。这里解释一下，为什么选阿里云。有鉴于前面试用了一大波 VPS 服务，我发现只有阿里云算是最稳定的，虽然带宽只有 1Mbps (指从我们个人电脑访问 VPS 的网速，而在 VPS 上面安软件时，下载软件包的速度其实是很快的，因为用的是阿里云的镜像，所以相当于内网传输数据)，但是胜在稳，终端输入命令基本不会有任何延迟。</p><p>租完 VPS，ssh 连接到它，然后就是搭建某 socks 服务了，网上资料非常多。需要注意的是，阿里云服务器需要配置安全组规则的，不然无法提供服务。假设某 socks 使用 23333 号端口来提供服务，那么需要下图那样配置一条入方向的规则：</p><p><img src="http://tao93.top/images/2018/09/01/1535789407.png" alt=""></p><p>入方向表示数据流向 VPS 的，协议类型选 TCP，对绝大部分服务来说，都是 TCP 协议，端口范围就是 VPS 上面提供的服务所使用的端口了。如果没有这个配置，那么我们个人电脑将无法向 23333 号端口发起请求。另外出方向默认全开了，所以不需配置。</p><h4 id="注册域名"><a href="#注册域名" class="headerlink" title="注册域名"></a>注册域名</h4><p>我挑了个很便宜的，36块钱 3 年，域名就是 tao93.top，也算是和我的名字和出生年份有些关联吧。</p><h4 id="域名绑定-IP"><a href="#域名绑定-IP" class="headerlink" title="域名绑定 IP"></a>域名绑定 IP</h4><p>这个还是要提一下的。在阿里云注册的域名，需要实名认证 (上传单面身份证照片) 才行，一开始我不知道，傻乎乎的总等，一边等，一边 ping 和 nslook 我的域名，好在实名认证很快，基本上提交认证后，1小时内就有人处理。我认证时有点搞笑，我传了一张 jpeg 后缀的图片，然后审核者回复说，需要 jpg 或 bmp 后缀的图片。我有点吃鲸，然后把同一张图片后缀改成了 jpg，上传，然后认证就成功了。。。认证结束后，就可以设置解析规则了：</p><p><img src="http://tao93.top/images/2018/09/01/1535789454.png" alt=""></p><p>只需要上面红框中的一条规则就可以把 tao93.top 解析了，mail 的那条规则，我现在还用不上。添加规则的时候，如果拿不准，可以在下图中只在记录值填公网 IP 地址即可：</p><p><img src="http://tao93.top/images/2018/09/01/1535789477.png" alt=""></p><p>我当时也是有点傻，觉得香港的 VPS 算是境外，就在解析线路选了境外，然后傻等了好久，后面换成默认后，基本几分钟就可以解析了。</p><h4 id="搭博客系统"><a href="#搭博客系统" class="headerlink" title="搭博客系统"></a>搭博客系统</h4><p>先说下为什么我没用 hexo 静态博客，因为静态博客无法评论，我觉得评论还是挺有必要的，虽然可以嵌入第三方评论服务，但是这种需要评论者用社交账号登录，麻烦，另外评论的数据全在别人手里，我觉得不好。所以我就要自己搭一个有后台的博客了。珂神使用的 zblog 是一个，国产的，看起来不那么华丽；WordPress 是另一个。我两个都装了，先装了 zblog，觉得有点点简单粗糙，然后就删的一干二净，装了 WordPress，然后发现 WordPress 复杂的让我有点迷失，我就想简单的写写东西，不想要那么多东西。然后我就在保留 WordPress 的基础上，又装了 zblog。</p><p>zblog 有个 php 版本，和 WordPress 的技术组合一模一样，就是 php + 数据库 + nginx 等 web server，其中 zblog 的数据库还可以用 sqlite，虽然我没成功过。我第一次装 zblog 时，手动安装了 MySQL，php，nginx，然后摸索着各种配置，搞了蛮久才搞定的。而 WordPress 的安装就很简单了，网上有 LNMP (Linux Nginx MySQL PHP) 组合包，等于一键就能装好环境，剩下的就是搞个 WordPress，并且替换掉 LNMP 原有的 web root 目录，就好了。</p><p>所以，无论 WordPress 还是 zblog，最简单的方式是，先装 LNMP 环境，然后就快了。需要记住一点的是，LNMP 环境会新建一个 www:www 用户(组) 来用于驱动 web 服务。务必需要让此 www 用户对于 web root 有 rwx 权限。比如 LNMP 默认的 web root 是 /home/wwwroot/default，那么一句 sudo chown -R www:www /home/wwwroot/default 即可。</p><h4 id="直接安装-z-blog-的过程"><a href="#直接安装-z-blog-的过程" class="headerlink" title="直接安装 z_blog 的过程"></a>直接安装 z_blog 的过程</h4><p>此过程配置比较麻烦，所以只是记录一下，不建议使用此方式。</p><p>装 nginx，设置开机自启，运行起来，然后别急着进浏览器验证，先到阿里云网站增加一下 80 号端口的安全规则，然后验证 nginx 是否可用。</p><p>建议更改一下 nginx 配置文件中的 root，即更改 web root 的位置，比如改为自己 home 中的某个目录，这样的话 chown web root 时不会有烦人的警告。</p><p>注意，nginx 需要重新加载配置文件，才能让配置文件的修改生效，方法是 sudo nginx -s reload 即可。</p><p>安装 Mysql，记得别忘记了 root 密码。</p><p>安装 Php，然后就是在 Php.ini 配置文件中，把各种 extension=php_mysql.dll 之类的语句解除注释，意思是 php 需要和 MySQL 数据库连接。但是这样的配置还不够，还需要 sudo apt-get install php7.0-mysql</p><p>这时候，可以下载 zblog 的压缩包，解压到 web root 中，然后浏览器打开 <a href="http://tao93.top，就可以开始安装" target="_blank" rel="noopener">http://tao93.top，就可以开始安装</a> zblog 了，安装好后就是各种 GUI 配置方式了。再次强调一下，需要 nginx 对应的 Linux 用户对于 web root 目录递归的有 rwx 权限。我第一次装 zblog 就是没设置权限，然后在后台首页中，「清空缓存并重新编译模板」一直转圈圈。</p><h4 id="配置主题，样式自定义，然后开始写博客。"><a href="#配置主题，样式自定义，然后开始写博客。" class="headerlink" title="配置主题，样式自定义，然后开始写博客。"></a>配置主题，样式自定义，然后开始写博客。</h4><p>略</p>]]></content>
      
      
        <tags>
            
            <tag> VPS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>博客系统迁移记录</title>
      <link href="/2018/09/01/%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/09/01/%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>此前我用的是 <a href="http://www.zblogcn.com/" target="_blank" rel="noopener">Z-blog 系统</a>，这个系统上手简单，不过仅支持在网页在线编写文章。这种方式弊端是比较死板，如果将来需要把文章移动到别的地方会很麻烦，而如果是用 MarkDown 来写文章就不会有这个麻烦了。本文就详细记录这次博客系统迁移的细节，包含 Linux 系统配置、Nginx 的配置、<a href="https://hexo.io/" target="_blank" rel="noopener">hexo</a> 的配置和 deploy 脚本等内容。</p><p>首先是，这次又把 VPS 的 Server 硬盘重置了，每次重置后都需要重新设置配置一遍 Linux 系统（我的 VPS 是 Ubuntu 16.04），所以这次记录一下配置的过程，也就是各种配置命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">adduser liutao <span class="comment"># add user, with root user</span></span><br><span class="line">usermod -aG sudo liutao <span class="comment"># add sudo permission, with root user</span></span><br><span class="line">su - liutao <span class="comment"># switch to user liutao</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># update repository info</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment"># configure shadowsocks</span></span><br><span class="line">sudo apt install python-pip</span><br><span class="line">sudo pip install shadowsocks</span><br><span class="line">sudo mkdir /etc/shadowsocks</span><br><span class="line"></span><br><span class="line"><span class="comment"># create config file</span></span><br><span class="line">sudo vim /etc/shadowsocks/ss.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"server"</span>:<span class="string">"0.0.0.0"</span>,</span><br><span class="line">    <span class="string">"server_port"</span>:22222,</span><br><span class="line">    <span class="string">"local_port"</span>:1080,</span><br><span class="line">    <span class="string">"password"</span>:<span class="string">"your pass word"</span>,</span><br><span class="line">    <span class="string">"timeout"</span>:1000,</span><br><span class="line">    <span class="string">"method"</span>:<span class="string">"aes-256-cfb"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># add service configuration info,.</span></span><br><span class="line">sudo vim /etc/systemd/system/shadowsocks.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks Server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/bin/ssserver -c /etc/shadowsocks/ss.json</span><br><span class="line">Restart=on-abort</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># start shadowsocks service</span></span><br><span class="line">sudo systemctl start shadowsocks</span><br><span class="line"></span><br><span class="line"><span class="comment"># start shadowsocks on startup</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> shadowsocks</span><br><span class="line"></span><br><span class="line"><span class="comment"># install linuxbrew</span></span><br><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Linuxbrew/install/master/install.sh)</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># install zsh</span></span><br><span class="line">sudo apt-get install zsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># install oh my zsh, this dependends on zsh</span></span><br><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br><span class="line">vim .zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># install Nginx, MySQL, Php</span></span><br><span class="line">wget http://soft.vpser.net/lnmp/lnmp1.5-full.tar.gz</span><br><span class="line">gunzip lnmp1.5-full.tar.gz</span><br><span class="line">tar xf lnmp1.5-full.tar</span><br><span class="line"><span class="built_in">cd</span> lnmp1.5-full</span><br><span class="line">sudo ./install.sh lnmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># install word-press</span></span><br><span class="line">wget https://wordpress.org/latest.zip</span><br><span class="line">unzip latest.zip -d wordpress</span><br><span class="line"></span><br><span class="line"><span class="comment"># set root to be/home/liutao/wordpress</span></span><br><span class="line">sudo vim /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span><br><span class="line">sudo nginx -s reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后本地浏览器打开 http://tao93.top/ 开始设置 WordPress</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create database named wordpress</span></span><br><span class="line">mysql -u root -p</span><br><span class="line">&gt; create database wordpress</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后在浏览器中填入刚刚的 database 名字，及其他信息</span></span><br><span class="line"><span class="comment"># 在 server 中的 WordPress 根目录中创建 wp-config.php 并填入浏览器页面显示的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到 nginx 使用的 config 文件</span></span><br><span class="line">sudo nginx -t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了解决一些权限问题，www 是 nginx 配置文件中声明的 web server 的 user name</span></span><br><span class="line"><span class="comment"># 这样就把 group 改为了 www，并且 group 用户都有 write 的权限</span></span><br><span class="line">sudo chgrp -R www &lt;root_dir_of_wordpress&gt;</span><br><span class="line">sudo chmod -R g+w &lt;root_dir_of_wordpress&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外还在 &lt;root_dir_of_wordpress&gt; 中的 wp-config.php 文件中插入了 define('FS_METHOD','direct'); 这样一行，不知道是不是必要的</span></span><br></pre></td></tr></table></figure><p>以上就是最终配置到 WordPress 的过程。之所以配置 WordPress，是因为我查到 WordPress 可以使用 Markdown，另外 WordPress 自带评论功能，插件和主题也非常丰富，所以就先使用 WordPress。结果发现 WordPress 的 Markdown 还需要安装插件才能支持，另外支持也不是很好，比如代码块会把比较长的行转行显示（即不是可以左右滑动），代码行号与高亮都没要。</p><p>所以，我还是痛下决心，换回到 hexo。hexo 比较简单，本地安装 hexo 后，在空目录中执行 hexo init 即可生成一堆相关文件，其中的 public 用来存放从当前 theme 和 markdown 文件生成的 static web 文件；而 source 目录用来存放 markdown 文件。简单使用步骤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in hexo root directory</span></span><br><span class="line">hexo g <span class="comment"># generate static web files</span></span><br><span class="line"></span><br><span class="line">hexo server <span class="comment"># start local web server, then browse http://localhost:4000 to preview web pages</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># copy files in public to server's directory, therefore updated pages can be browsed at http://tao93.top/</span></span><br></pre></td></tr></table></figure><p>以上就是简单的用法，不过实际上我做了一些额外工作。例如为了避免 markdown 文件意外丢失，我们需要把它们备份到 server 上，server 和 local 同时丢失的可能性极小。另外，markdown 中插入图片时，可以先把图片放在本地，然后 markdown 中指向图片的本地路径，这样生成的 web 文件会把图片拷贝到 public 目录中某处，然后 html 文件引用 public 目录中的 image，这时的引用其实就是一个 url 了。但是我不是这样做的，我是先把要插入的图片拷贝到 Server 的 public 目录某处，这样就会得到一个指向次图片的 url，然后再 markdown 中直接使用这个 url。这样的话，只要 server 的图片库保持稳定，markdown 文件就不用和本地图片库绑定在一起。同样的，server 的图片库也需要备份到 local，以确保安全。下面就开始介绍以上两点。</p><p>首先是本地 source 目录需要备份到 server 上，我的方式是本地 source 目录使用 git 来追踪，然后 server 上简历一个 bare repository source.git，这样本地的每次 commit 都 push 到 server 上的 source.git，就可以作为备份了。相应的本地的 public 目录也要 push 到 server 上的 public.git 这样一个 bare repository，然后在 server 上的 public 中，从 public.git 这个 remote git pull 一下，这样 server 中的 public 就有了最新的 web 文件。</p><p>接下来是图片上传到 server 中，为了方便，我写了一个 Python 脚本，用来把本地图片上传到 server，或者把剪贴板的图片 (便于复制图片的情景) 上传到 server，然后将对应的 url 粘贴到剪贴板，这样的话，只需要执行这个 Python 脚本，就可以上传本地图片或者剪贴板上的图片，并把得到的 url 复制到剪贴板，然后就可以直接粘贴到 markdown 中。以下是这个 upload_pic.py 脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageGrab, Image</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line"><span class="comment"># store image files in date format directory path in server</span></span><br><span class="line">date_path = now.strftime(<span class="string">'%Y/%m/%d'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># use timestamp as image file name in server</span></span><br><span class="line">f_name = str(int(now.timestamp()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) == <span class="number">1</span>:</span><br><span class="line">    <span class="comment"># get picture in clipboard</span></span><br><span class="line">    im = ImageGrab.grabclipboard()</span><br><span class="line">    <span class="comment"># check whether it's a picture</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(im, Image.Image):</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># file name in server</span></span><br><span class="line">        f_name = str(int(datetime.datetime.now().timestamp())) + <span class="string">'.png'</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># save in local</span></span><br><span class="line">        im.save(f_name)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># the url of the image</span></span><br><span class="line">        url = <span class="string">'http://tao93.top/images/'</span> + date_path + <span class="string">'/'</span> + f_name</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># copy the url to clipboard</span></span><br><span class="line">        os.system(<span class="string">"echo '%s' | pbcopy"</span> % url)</span><br><span class="line">        print(<span class="string">'url has been copied'</span>)</span><br><span class="line">        print(<span class="string">'copying...'</span>)</span><br><span class="line">        dest_path = <span class="string">'/home/liutao/hexo_blog/public/images/'</span> + date_path</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># mkdir in server and copy the image</span></span><br><span class="line">        os.system(<span class="string">"ssh liutao@tao93.top 'mkdir -p "</span> + dest_path + <span class="string">"'"</span>)</span><br><span class="line">        os.system(<span class="string">'scp '</span> + f_name + <span class="string">' liutao@tao93.top:'</span> + dest_path)</span><br><span class="line">        print(<span class="string">'copy finished'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># remove local image file</span></span><br><span class="line">        os.remove(f_name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'clipboard content is not a image!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> len(sys.argv) == <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(sys.argv[<span class="number">1</span>]):</span><br><span class="line">        <span class="comment"># file name in server</span></span><br><span class="line">        f_name = str(int(datetime.datetime.now().timestamp()))</span><br><span class="line">        dot_loc = sys.argv[<span class="number">1</span>].rfind(<span class="string">'.'</span>)</span><br><span class="line">        <span class="keyword">if</span> dot_loc &gt;= <span class="number">0</span>:</span><br><span class="line">            f_name += sys.argv[<span class="number">1</span>][dot_loc:] <span class="comment"># append the file extension</span></span><br><span class="line">        </span><br><span class="line">        url = <span class="string">'http://tao93.top/images/'</span> + date_path + <span class="string">'/'</span> + f_name</span><br><span class="line">        os.system(<span class="string">"echo '%s' | pbcopy"</span> % url)</span><br><span class="line">        print(<span class="string">'url has been copied'</span>)</span><br><span class="line">        print(<span class="string">'copying...'</span>)</span><br><span class="line">        dest_path = <span class="string">'/home/liutao/hexo_blog/public/images/'</span> + date_path</span><br><span class="line">        os.system(<span class="string">"ssh liutao@tao93.top 'mkdir -p "</span> + dest_path + <span class="string">"'"</span>)</span><br><span class="line">        os.system(<span class="string">'scp '</span> + sys.argv[<span class="number">1</span>] + <span class="string">' liutao@tao93.top:'</span> + dest_path + <span class="string">'/'</span> + f_name)</span><br><span class="line">        print(<span class="string">'copy finished'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(sys.argv[<span class="number">1</span>] + <span class="string">' is not a file!'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'too much arguments'</span>)</span><br></pre></td></tr></table></figure><p>为了简化步骤，我写了一个 deploy.sh 脚本放在本地 hexo blog 根目录中，这样只需要在 source 目录中编辑 markdown 文件，然后 commit，再调用 deploy.sh 脚本即可。此脚本把其他要做的事情都做了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># into source </span></span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">source</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># make sure it's commited in source directory</span></span><br><span class="line">status=$(git status -s)</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$status</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># git push in source</span></span><br><span class="line">    git push</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'not commited in source directory!'</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># back into parent directory</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate static web files</span></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line"><span class="comment"># git push in local public directory</span></span><br><span class="line"><span class="built_in">cd</span> public</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">'update web files'</span></span><br><span class="line">git push</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># git pull in server's public directory</span></span><br><span class="line">ssh liutao@tao93.top <span class="string">'cd /home/liutao/hexo_blog/public; git pull'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># git commit in server's images directory</span></span><br><span class="line">ssh liutao@tao93.top <span class="string">'cd /home/liutao/hexo_blog/public/images; git add .; git commit -m "add images"'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># git pull in local's images directory</span></span><br><span class="line"><span class="built_in">cd</span> images</span><br><span class="line">git pull</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'========='</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'Finished!'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'========='</span></span><br></pre></td></tr></table></figure><p>这样上面的脚本就把生成 web 文件，拷贝 public 中的 web 文件拷贝到 server，把 server 中的 image 目录中的信息更新到 local 的 images 目录这样几个事情。</p><p>附：</p><p>如果要本地 git repo 没有 commit，remote repo 有 commit，现在需要本地的 master 分支 track remote 的 master 分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先添加 origin，设置好 url</span></span><br><span class="line">git remote add origin liutao@tao93.top:/home/liutao/hexo_blog/public/images/.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后 fetch 一下 远程的状态</span></span><br><span class="line">git fetch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时如果 git pull --set-upstream-to 是不行的，会说本地 master 分支不存在，而需要下面这样才行</span></span><br><span class="line">git checkout master</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Other </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>记一次混淆问题导致的 bug</title>
      <link href="/2018/09/01/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%B7%B7%E6%B7%86%E9%97%AE%E9%A2%98%E5%AF%BC%E8%87%B4%E7%9A%84%20bug/"/>
      <url>/2018/09/01/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%B7%B7%E6%B7%86%E9%97%AE%E9%A2%98%E5%AF%BC%E8%87%B4%E7%9A%84%20bug/</url>
      <content type="html"><![CDATA[<p>最近把 <a href="https://github.com/card-io/card.io-Android-SDK" target="_blank" rel="noopener">Card.IO</a> 改造成一个 aar 依赖提供给公司的项目使用。这个 aar 中使用了几个 so 库。只不过没有提供 armeabi 类型的 so 库，而只有 armeabi-v7a 和 armeabi-v8a 之类的 so 库。所以初次提供给公司项目使用时，出现了找不到 so 的错误，也就是 UnsatisfiedLinkError 错误。也就是下面这样的提示：</p><p><img src="http://tao93.top/images/2018/09/01/1535807292.png" alt=""></p><p>后面我想尽办法提供了 armeabi 类型的 so 库，这个问题就算告一段落了，然后这还不是结束。今天，测试又发了一段崩溃日志，也就是下面这样的日志：</p><p><img src="http://tao93.top/images/2018/09/01/1535807316.png" alt=""></p><p>因为之前出现过找不到 so 库的问题，所以乍一看上面的日志，我们都以为又是找不到 so 库 (为我们的菜表示羞愧 🤩)。然后经过上网查找，并和 native 的代码对比，我才意识到，上面的日志其实是 so 库是找到了的，只不过是加载 so 库时，调用 JNI_onLoad 这个 native 方法时出错了。此外，向测试要了 debug 包，发现没有问题，所以初步断定是混淆的问题，然后就是排查了。</p><p>我把测试提供给我的 release 包反编译，然后和 JNI_onLoad 方法中的 native 代码对比，终于找到原因了：release 包中，我提供的库的某个方法被混淆掉了，但是这个方法是需要被 JNI_onLoad 方法调用的。所以问题就是：一个需要被 so 库调用的 Java 方法被混淆了！其实，很多时候我们的项目引入一些著名的第三方包 (比如 Knife 之类的) 时，都会在我们的项目的 Proguard 配置文件中声明不要混淆这些三方包的代码，为的就是避免上面这个问题。说一句显得有点废话的话：第三方包发布混淆包时，他们的 Proguard 配置文件只能在他们的 aar 包构建时生效，而在他们的 aar 构建到我们的项目中时，他们的 Proguard 早已鞭长莫及不起作用了。</p><p>回到我遇到的这个问题，我们本地自测时，很少会进行混淆，本地的 release 默认都是未混淆的 (minifyEnabled 是 false)，所以自测的时候根本没有注意到这个问题。这次这个 bug 的解决办法之一是，在最终使用我的 aar 的项目中，显示声明不要混淆我这个 aar 中的某些代码，这就和上一段说的声明不混淆第三方包的代码是一样的。But，还有一种更好的方法，那就是使用 com.android.support.support-annotations 支持库中的 @Keep 注解，此注解可以标记哪些方法或者类在最终构建 apk 时不会被混淆掉 (当然在前面的 aar 构建等过程自然也不会混淆)。</p><p>总结一下，当前项目的 Proguard 配置文件只能在当前项目构建输出产物时起作用，而无法确保输出的产物交给其他项目集成时不被混淆。若要确保后者，那就可以用 support-annotations 支持库中的注解了。</p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>记一个简单的递归问题与解法</title>
      <link href="/2018/09/01/%E8%AE%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E6%B3%95/"/>
      <url>/2018/09/01/%E8%AE%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>递归问题就像是俄罗斯套娃一样精妙，大的套小的，一层一层套在一起。</p><p>前些日子，一个朋友说看到一个算法题目，然后问我有思路吗？问题就是下面这样的：</p><p><img src="http://tao93.top/images/2018/09/01/1535807089.png" alt=""></p><p>这个问题很明显是个递归问题。我当时就夸下海口说，10分钟给你写个 Python 脚本。虽然实际上用了接近 30 分钟。。。</p><p>言归正传，这个问题的递归关系包含两种，<strong>嵌套关系</strong>和<strong>并列关系</strong>。比如 2[a]3[c] 最外层是并列关系，即 2[a] 和 3[c] 是两个互相并列的子问题，他们的解答串起来就是 2[a]3[c] 的解答。而 2[2[a]] 最外层则是一个嵌套关系，即要求 2[2[a]] 的解答需要先求子问题 2[a] 的解答 (这个解答显示就是 aa)，所以问题化解为 2[aa]。</p><p>所以思路就是，对于一个问题 X，先按并列关系划分为若干个子问题 X1, X2, …, Xn；如果 n 大于 1，那么各个子问题的答案串起来就是答案了；如果 n 等于 1，那么说明 X 最外层并不是并列关系而是嵌套关系或者根本就是单个字母，如果 X 是单个字母，那么答案就是它本身，反之，那么 X 一定是 s[Y] 的形式，答案就是 s 个 Y 的答案串起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p_loc</span><span class="params">(input, left)</span>:</span></span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    i = left</span><br><span class="line">    <span class="keyword">while</span> count &gt; <span class="number">0</span>:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> input[i] == <span class="string">']'</span>:</span><br><span class="line">            count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> input[i] == <span class="string">'['</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">(input)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'['</span> <span class="keyword">not</span> <span class="keyword">in</span> input:</span><br><span class="line">        <span class="keyword">return</span> input</span><br><span class="line">    first = input.find(<span class="string">'['</span>)</span><br><span class="line">    i = p_loc(input, first)</span><br><span class="line">    <span class="keyword">if</span> i &lt; len(input) <span class="number">-1</span>:</span><br><span class="line">        parts = []</span><br><span class="line">        <span class="keyword">while</span> i &lt; len(input) <span class="number">-1</span>:</span><br><span class="line">            parts.append(input[:i+<span class="number">1</span>])</span><br><span class="line">            input = input[i+<span class="number">1</span>:]</span><br><span class="line">            first = input.find(<span class="string">'['</span>)</span><br><span class="line">            i = p_loc(input, first)</span><br><span class="line">        parts.append(input[:i+<span class="number">1</span>])</span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> part <span class="keyword">in</span> parts:</span><br><span class="line">            res += do(part)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right = p_loc(input, first)</span><br><span class="line">        sub_res = do(input[first+<span class="number">1</span>:right])</span><br><span class="line">        <span class="keyword">return</span> int(input[:first]) * sub_res</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">print(do(<span class="string">'2[a]3[c]'</span>))</span><br><span class="line">print(do(<span class="string">'2[2[a]]'</span>))</span><br><span class="line">print(do(<span class="string">'2[2[a]]3[c]'</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>日常修 Bug</title>
      <link href="/2018/09/01/%E6%97%A5%E5%B8%B8%E4%BF%AE%20Bug/"/>
      <url>/2018/09/01/%E6%97%A5%E5%B8%B8%E4%BF%AE%20Bug/</url>
      <content type="html"><![CDATA[<p>前几天有人报告巴西版本乘客端扫描银行卡的界面有 bug，即屏幕右侧有一条白线，也就是下图所示。</p><p><img src="http://tao93.top/images/2018/09/01/1535790364.png" alt=""></p><p>鉴于报告人没提具体的版本号，也没提怎么出现的，也没提是什么机型出现的，我就和报告人说沟通了一番。报告人说应该是小米 6 出现这个问题，我遂借了一部小米 6，然后运行 demo 并没有复现。现在就有两种可能，第一是只有报告人那台小米 6 有问题，第二是 demo 没问题但是集成到巴西版本后就有问题了。经过艰苦交涉，终于从对方那里要到了一个安装包后，我手里手机复现了此问题，事实很快就清楚了：demo 没问题但是集成后有问题，也就是和机型压根没关系。</p><p>先直接给出最后修复的方法，修复方法是在我的扫卡库的 activity 中，调用以下一行就 OK 了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给 PhoneWindow 设置一个背景 </span></span><br><span class="line">getWindow().setBackgroundDrawable(<span class="keyword">new</span> ColorDrawable(Color.TRANSPARENT));</span><br></pre></td></tr></table></figure><p>嗯，修复方法很简单，但是为什么这样做就 work 了呢？接下来就是调试的过程了.</p><p>首先获取一下这个界面的 layout 信息，尝试看看右侧白色细线是不是额外塞进去的视图，结果并不是。然后我再看是否是设置了什么 padding 导致了这个问题。事实上，正式这样的，可惜我可能是瞎了眼，居然没有看到下面的线索，即 DecorView 的右侧 padding 是 2：</p><p><img src="http://tao93.top/images/2018/09/01/1535790424.png" alt=""></p><p>我只看到了下面的 LinearLayout 的宽度是1438，比我的手机屏幕宽度1440少了2个像素，显然就是右侧的白线了。</p><p><img src="http://tao93.top/images/2018/09/01/1535790483.png" alt=""></p><p>所以我怎么办呢，我开始调试 measure 和 layout 的过程。因为 DecorView 的宽度是 1440 没错，可是它的 Child LinearLayout 宽度只有 1438，所以我先条件断点在 LinearLayout 类中的 onMeasure 方法。断点的条件我本来想写 getParent() instance DecorView，结果发现无法应用 DecorView，于是我就改成了 getParent() != null &amp;&amp; getParent().getParent() == null，其实这是不对的，DecorView 同样有 Parent，也就是 ViewRootImpl 对象，我把这个给忘了。所以断点条件就成了下面这样臃肿的了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getParent() != <span class="keyword">null</span> &amp;&amp; getParent().getParent() != <span class="keyword">null</span> &amp;&amp; getParent().getParent().getParent() == <span class="keyword">null</span> </span><br><span class="line"><span class="comment">// 当然其实还有更简洁的方式，比如下面这样 </span></span><br><span class="line">getClass().getName.endswith(<span class="string">"DecorView"</span>)</span><br></pre></td></tr></table></figure><p>然后发现不管是 measure 还是 layout 的过程，LinearLayout 宽度始终就是 1438，DecorView 就只给它留了这个大空间。然后我开始调试到 DecorView 的测量过程中，最后发现在 ViewGroup (这里仅仅是由于 DecorView 是继承自 ViewGroup 的) 的 measureChildWithMargins 方法中，找到了关键线索：</p><p><img src="http://tao93.top/images/2018/09/01/1535790538.png" alt=""></p><p>也就是上面的 mPaddingRight 的值居然是 2 而不是 0，这意味着 DecorView 的右侧 padding 是2，这样就能解释通为啥 DecorView 的 child 宽度小了 2 了。这是我赶紧回去看 layout 信息，然后就发现了我本来早就该发现的线索了。</p><p>OK，接下来是要知道，谁把 DecorView 的右侧 padding 加了 2 的。我对 View 类的 mPaddingRight 属性加了下图所示的断点：</p><p><img src="http://tao93.top/images/2018/09/01/1535790585.png" alt=""></p><p>果然，不一会儿，我就有了收获，得到了下面的堆栈：</p><p><img src="http://tao93.top/images/2018/09/01/1535790614.png" alt=""></p><p>上面堆栈清晰了展示了右侧 padding 是怎么被设置为 2 的，概括来说，就是 PhoneWindow 在准备 DecorView 时，检查到有一个 Drawable，然后在设置这个 Drawable 时，去设置了 padding。那么为什么设置 Drawable 需要设置 padding 呢？看下图就明白了：</p><p><img src="http://tao93.top/images/2018/09/01/1535790640.png" alt=""></p><p>原来，这是个自带 padding 的 NinePatchDrawable。接下来，我就查找了一下，发现这个 drawable 就是 PhoneWindow 中的 mBackgroundsource 属性解析而来。这个属性是从应用主题中指定的。现在回到前面我提前贴出的解决方法之一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getWindow().setBackgroundDrawable(<span class="keyword">new</span> ColorDrawable(Color.TRANSPARENT))</span><br></pre></td></tr></table></figure><p>上面的代码调用 PhoneWindow 的 setBackgroundDrawable 方法，这个调用除了设置 bg drawable 外，还直接让 mBackgroundsource 变为 0，所以后面就轮不到那个 NinePatchDrawable 了。</p><p>其实，上面的解决方法还是有点突兀，另一种方法是，在扫卡的库中设置一个主题，这样的话，就不会应用巴西版本乘客端项目中声明的主题了，自然也就不会把那个 NinePatchDrawable 设置进来。</p><p>再说点别的。这个扫卡的库，被集成到另一个库中，然后另一个库再集成到巴西版本中。中间这个库，我是没有涉足的。所以为么验证我有没有修复成功，我只能在最终的项目中再引用一下我的库经过改动后的版本，当然版本号也要增加一下。这样的话，就可以新的覆盖旧的，把中间那个库对扫卡库的引用给覆盖的。唉，真是折腾。</p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>提高开发效率的各种工具</title>
      <link href="/2018/09/01/%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E5%90%84%E7%A7%8D%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/09/01/%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E5%90%84%E7%A7%8D%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<p>俗话说，工欲善其事必先利其器。好用的开发工具，虽然不会直接改善我们写的代码，但是对于效率的提高和提高舒适度还是很有帮助的。本文意在提供一些不是非常普遍使用，但是对于效率提升可能非常有用的工具。话不多说，开始正文！</p><h4 id="剪贴板工具-—-Clipy"><a href="#剪贴板工具-—-Clipy" class="headerlink" title="剪贴板工具 —- Clipy"></a>剪贴板工具 —- <a href="https://github.com/Clipy/Clipy" target="_blank" rel="noopener">Clipy</a></h4><p>剪贴板工具实在太实用了，不过似乎大部分程序员都没有用上剪贴板工具。而 Clipy 是一款很合适的剪贴板工具，以至于我想起它时，直接将它插到最前面，并且序号编为 0。Clipy 是一个开源的剪贴板工具，简洁不闹心，复制的图片和文本都可以管理，用起来很爽。</p><p><img src="http://tao93.top/images/2018/09/01/1535789967.png" alt=""></p><h4 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h4><p>这是个终端加强工具，macOS 和 Linux 都可用，把默认 shell 从 bash 改为 zsh，然后再加强一下。我只用的 oh-my-zsh 的 3 个 features，但这 3 个都是很有吸引力的。</p><p>第一、自带识别 git 项目目录的功能，直接显示分支名、有无未提交的本地修改；</p><p>第二、cd 时，直接不停的按 tab，指导选中了你想要的目录，然后回车，就可以进入想进入的目标，减少输入目录名前几个字母的劳累。</p><p>第三、这是个 killer feature，在终端输入任何几个字符，按向上的箭头，就可列出以这些字符开头的所有历史命令，这样很多需重复使用的命令、很久忽然想起需要再次使用的命令的使用方便了非常多，比如忽然想起 10 天前，使用 sed 命令搞了个事情，但是 sed 命令你懂的，压根记不住用法，怎么办？直接终端输入 sed 然后按向上箭头，立马调出 sed 开头的历史命令。</p><h4 id="local-Maven-仓库"><a href="#local-Maven-仓库" class="headerlink" title="local Maven 仓库"></a>local Maven 仓库</h4><p>自打谷歌一手将 Android 的构建工具切换到 Gradle 后，远程依赖变为用由 Gradle 配置从 Maven 仓库获取依赖。而除了 Jcenter、mavenCentral、Google 这样最常见 3 个公开 Maven 仓库外，现在很多公司内部会开发一些 SDK 或者工具包之类的，然后作为依赖放在公司内部的私有 Maven 仓库中，提供给公司内部使用。</p><p>问题来了，对于普通的开发者来说，有时候需要修改某个依赖的源代码并加以验证，但是又不想把修改后的代码马上就构建一个新版本的依赖传输到公司的 Maven 仓库。毕竟，天晓得自己要改多少次，如果一直往公司 Maven 仓库推，被别人看到了好像会感觉自己很菜的样子 ?。这时候，如果有一个本地的 Maven 仓库，那先传到本地 Maven 仓库，然后再从本地仓库获取依赖，就可以避免这个问题了，特别是对于一些文件比较大的依赖，这样速度也会更快。</p><p>这里说的 local Maven 仓库，不是 Gradle 中使用 mavenLocal() 来声明的那个仓库 (通常位于 ~/.m2/repository) 中，而是指自己在个人电脑上搭建一个 Maven 仓库，就和远程仓库一样，只不过域名使用 localhost 来访问即可。</p><p>方法其实比较简单，比如使用 Nexus OSS Maven 的话，在 macOS 系统上简直不要太容易，直接 brew install nexus，然后再 nexus start 就 OK了，此时在浏览器上面打开 <a href="http://localhost:8081/nexus" target="_blank" rel="noopener">http://localhost:8081/nexus</a> 就可以开始登录了，初始用户名和密码分别是 admin 和 admin123，登录之后，里面已经有了一些 repository 了，如下图所示：</p><p><img src="http://tao93.top/images/2018/09/01/1535790041.png" alt=""></p><p>我常用的就是上面 Snapshots 这个 repository，专门用来托管 SNAPSHOT 类型的依赖，关于 SNAPSHOT 类型的依赖，我会写一篇更全面详细的文章来讲怎么使用。</p><p>OK，现在就可以在向本地的 Maven 仓库传依赖包并拉取使用了。其实，局域网内其他同事也是可以访问这个 Maven 仓库的，比如 <a href="http://localhost:8081/nexus/content/repositories/snapshots/" target="_blank" rel="noopener">http://localhost:8081/nexus/content/repositories/snapshots/</a> 这个仓库，别的同事要访问我这个 snapshot 仓库的话，只需要他把 localhost 换成我的私有 IP 地址即可。</p><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p>为什么把 Python 列出来呢？因为其实 Python 入门是非常简单的，再加上这年头，不了解一下 Python 都不好意思说自己是程序员。而入门后，可以帮我们做点事情，比如下图中，表达式计算，进制转换:</p><p><img src="http://tao93.top/images/2018/09/01/1535790099.png" alt=""></p><p>其实 Python 可以做的事很多，通过引入 Python 自带的包或者第三方库的包，Python 几乎无所不能。举个例子，去年微信跳一跳小游戏刚出来时，我看这个游戏非常简单，我就想，能不能用 Python 做个自动化脚本来跳呢？当然可以！其实原理也很简单，对于每一跳，可以分为若干步：截图、分析图片得出需要跳跃的距离、根据距离来模拟一个长按事件。这样的三个步骤对于 Android 设备是很容易实现的。所以思路就是，使用 Python 调用 adb 工具来截图、pull 截图到电脑中；然后使用 Python 的照片处理库来分析照片的像素，找到跳的那个东西的位置和下一个方块的位置，这样就知道需要跳跃的距离了；调用 adb 模拟一个长按屏幕的事件，长按的时间和需要跳跃的距离成正比，至于这个比值系数，摸索几次测试一下就可以了。详见我的博客 <a href="http://tao93.top/2018/09/01/Python%20也能玩跳一跳小游戏/">Python 也能玩跳一跳小游戏</a>。</p><h4 id="我改进过的-JD-GUI"><a href="#我改进过的-JD-GUI" class="headerlink" title="我改进过的 JD-GUI"></a>我改进过的 JD-GUI</h4><p>恬不知耻的推荐一下我<a href="https://github.com/Tao93/jd-gui" target="_blank" rel="noopener">更改过的 JD-GUI</a>。<a href="https://github.com/java-decompiler/jd-gui" target="_blank" rel="noopener">JD-GUI</a> 本来是一个开源项目，但是已经3年没有维护了。两年前，当时因为工作需要，我要频繁的解压 apk，把 dex 文件转成 jar，然后再用 JD-GUI 反编译查看代码注入效果，所以我就想，这么三个步骤能不能一步搞定。于是经过一个周末的努力，我小改了一下 JD-GUI，使其支持直接拖入 apk 文件，然后自动解压，自动调用 apktool 来将 dex 转成 jar 文件，然后再交给原 JD-GUI 反编译。PS：我非常贴心的提供了 macOS、Windows、Linux 三个平台的 binary 包。</p><h4 id="the-Unarchiver-for-macOS"><a href="#the-Unarchiver-for-macOS" class="headerlink" title="the Unarchiver for macOS"></a><a href="https://itunes.apple.com/cn/app/the-unarchiver/id425424353?mt=12" target="_blank" rel="noopener">the Unarchiver</a> for macOS</h4><p>macOS 自带的解压工具比较弱鸡，比如 jar 文件无法解压，一些别的压缩包解压时也会出幺蛾子。而这款 the Unarchiver for macOS 体积不大，简洁却可以应付几乎所有的解压场景，还能提供选择 charset 的机会，从而解压某些压缩包时避免文件名乱码。</p><h4 id="USTC-Mirror"><a href="#USTC-Mirror" class="headerlink" title="USTC Mirror"></a><a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">USTC Mirror</a></h4><p>在此推荐一下中国科大开源镜像，这份镜像可以使得在国内访问很多开源软件的速度飞起来。</p><p>比如<a href="http://mirrors.ustc.edu.cn/help/pypi.html" target="_blank" rel="noopener">给 pip 设置代理</a>，可以让 pip 下载 Python 扩展包的速度快得飞起。</p><p>再比如使用<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/aosp" target="_blank" rel="noopener">中国科大的 AOSP 镜像</a>，获取 AOSP 项目的源码 (几十 GB 大小) 的速度将要加快很多，如果不使用代理，那么从 <a href="https://source.android.com/setup/build/downloading" target="_blank" rel="noopener">Google 官方同步 AOSP 代码</a>，其难度你懂的。</p><p>再再比如，非常流行的 <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a>，是 macOS 平台上使用命令行管理软件包及它们的依赖关系的工具，好比是 Linux 的包管理系统。此外 Homebrew 使用 cask tap 甚至还可以安装 Sublime text，Chrome 等许多的 GUI 软件，并自动建立软链接链接到 GUI 的软件的可执行文件，比如 Sublime text，使用 Homebrew 安装后，就可以在命令行使用 subl 即可打开 Sublime text 了。扯远了，Homebrew 同样存在在国内下载软件速度慢的问题，而同样，中国科大镜像提供了 <a href="http://mirrors.ustc.edu.cn/help/homebrew-bottles.html" target="_blank" rel="noopener">Homebrew 镜像</a>，能让绝大部分包的下载速度快起来。</p><p>最后，先对 USTC Mirror 的维护者表示感谢。然后，我想说这个镜像的内容非常多，绝大部分我也不了解，也就是还有很多可以深入探索的东西。</p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>修车小能手上线</title>
      <link href="/2018/09/01/%E4%BF%AE%E8%BD%A6%E5%B0%8F%E8%83%BD%E6%89%8B%E4%B8%8A%E7%BA%BF/"/>
      <url>/2018/09/01/%E4%BF%AE%E8%BD%A6%E5%B0%8F%E8%83%BD%E6%89%8B%E4%B8%8A%E7%BA%BF/</url>
      <content type="html"><![CDATA[<p>修车技术也是技术，所以关于修车的博客也是技术博客啦 😝</p><p>事情要从两个月前说起，当时在京东买了一辆粉色的比德文电动车给女朋友上下班用。这辆电动车比较便宜，当时我们也不怎么注意预防电动车被雨淋，因为潜意识觉得经常看到别人的电动车被雨淋，所以应该没事。事情坏就坏在这辆电动车防水性真不好，所以几场大雨之后，还没到一个月，电动车就坏了，拧车把上的旋钮车子没反应，也就是电机不转了。</p><p>本着应该有专业人员 (后面事实证明修车的真不是个好东西) 修理的态度，大热天我费尽力气把电动车推到了修车铺。等了半天修车的才姗姗来迟的过来了。然后修车的打开电动车后盖瞧了瞧，说是控制器坏了，需要更换，他店里的控制器 80 块钱一个。这时候我和女朋友就和厂家联系，厂家称要么给我们50块钱，要么我们把旧控制器寄回去然后他们寄一个新的回来。我们心想，快递寄控制器一来一回要好多天，这些天我们的车子就要这么晾在离家几公里的地方，这怎么能忍！所以我们和厂家撕逼，最终厂家答应给我们 80 块，于是我们就在店里换了个控制器。坑爹的修车的，帮我们换控制器时慢慢腾腾，中途还停下来帮两个女的配钥匙！当时真的是很气愤，换个控制器换了接近两小时，期间修车的还不停用一种傲慢的态度数落我们不应该再网上图便宜买了个质量差的电动车，他店里卖的车怎么怎么好怎么怎么地。而当女朋友对修车的说：”你的意思是这个电动车各方面质量很差吗？” 修车的又开始含糊其辞。</p><p><img src="http://tao93.top/images/2018/09/01/1535789639.png" alt=""></p><p>换完之后，本来想这事就算结束了，该去找厂家要 80 块钱了。谁知道，事情才刚刚开始。当天，女朋友就说车子有问题，她把车子从地下车库推出来时，上一个很陡的坡时，车子动力不足上不去，上到一般就猛地往回退！最后还是一个男生好心把她推上来了。然后隔了两天，女朋友又去修车铺那里，询问为什么动力不行了。修车的骑着电动车走了一圈，给了这么句话「电机坏了」。本来我对修车的就没好印象，所以听到这里我是不信的，控制器坏了我信，电机也同时坏这也太扯淡了。所以我推断是控制器的适配性 (或者说和电动车的兼容性) 比较差，所以才会动力不足。不就我还发现别的问题，当拧着车把旋钮再捏刹车闸时，电机居然还在发力，这个最基本的安全机制都没了。此外，智能控制器在启动时噪音比较大。</p><p>抱着对控制器适配性的质疑，我找到了杭州一家比德文车店，从车店那里我算搞清楚了缘由。原来，修车的给我换的是所谓智能控制器，也就是基本啥电动车都能用，但是并不能对每种电动车都有最好的适配性，自然也远不如原装控制器。而原装控制器只能厂家寄过来，这个比德文车店也没有。另外，从厂家拿到原装控制器后，来这个店里安装的话，他们需要收 三四十块钱。</p><p>之后我就像厂家联系，表示不要 80 块钱了，我把坏了的原装控制器寄回去，厂家给我寄一个新的控制器。不得不吐槽，厂家动作非常慢，总共两三个星期我才拿到新的原装控制器。我才不像跑到比德文车店出几十块钱让他们帮我安装，所以接下来，我直接自己动手安装，其实安装很简单，就是把那些借口对应插上就好了。安装好后，我试着骑了骑，没了噪音，启动更快，后面两天女朋友也表示上坡时不会动力不足了。</p><p>到此好像已经结束了。不过如果就这样结束了，我还能称作修车小能手么！</p><p>才两三天，就出现拧旋钮后车轮 (电机) 不转的问题，但是又会忽然好了。又一次女朋友去上班骑到半路，忽然车轮不转了，把她吓一跳，后面的日子她就再也不敢骑了，她说还是要去修车店修一下才行。这样过了一个多星期，到了今天这个周六。我终于有时间去处理一下这件事了。</p><p>我有两个选择，一个是弄到修车店去，另一个是自己动手，我选择了后者，原因是间歇性的出问题，说明无法稳定复现，冉义弄到修车店，修车的搞半天说没毛病，那不就尴尬了嘛。今天我还特意骑着电动车绕小区一圈，问题依然没复现，这就很麻烦了。不过，我早就怀疑，这种间歇性的电机不转应该是接触不良的问题。所以今天我打算试试用排除法来看能否验证我的猜测。我打开后盖：</p><p><img src="http://tao93.top/images/2018/09/01/1535789679.png" alt=""></p><p>如上图所示，银白色铁盒子就是新的原装控制器，箭头所指的就是它连接到电动车的一些接口。都是那种带倒钩、直接插上就可以的接口。</p><p>修车也要讲安全，毕竟电池的电压有几十伏，可能会触电，所以我是这样来判断接口是否有问题的：断开电池和电动车的连接，拔开一个接口，连接上电池，最后转动旋钮看电机是否旋转，是的话说明这个接口压根不影响电机是否转动，否的话说明这个接口关键接口之一，会影响电机的旋转。</p><p>用上面的方法挨个接口尝试，我找到3个关键接口。如果问题真的是接触不良的话，很可能就是这 3 个接口之一接触不良，所以接下来我把这 3 个接口进行下一轮测试。测试方法是，把接口往外拔一点 (但是依然在倒钩锁定范围内)，这样就可以模拟现实中接口松动的情况了。如下图所示，左边是接口插很紧，图中箭头指的就是倒钩；右边是接口往外拔一点点，可以看到倒钩和一个凸起物之间已经没有间隙了。</p><p><img src="http://tao93.top/images/2018/09/01/1535789719.png" alt=""></p><p>通过模拟接口松动的情况，然后测试是否会导致电机不转，很快我就找到了一个接口，这个接口往外拔一点点，电机就无法转，往里插紧一点，电机就能转动了。</p><p>发现了问题所在，接下来就很好办了，用东西把这个接口固定紧就好了，让它一直保持插紧的状态。最好的材料应该细铁丝，用细铁丝扎紧然后用钳子拧紧就好。可是我明白细铁丝，所以我用绳子把它绑紧来，也就是下面图中这样：</p><p><img src="http://tao93.top/images/2018/09/01/1535789742.png" alt=""></p><p>为什么我前面说细铁丝更好呢，因为细铁丝拧紧后不会逆转变松，但是绳子是会的。用绳子帮硬的东西，总是会有那么写松动，无法彻底绑紧。所以在绑完后，我还用一根牙签挑过绳子，然后转两圈，这样绳子就会被绷得很紧了，就是下面这样的：</p><p><img src="http://tao93.top/images/2018/09/01/1535789781.png" alt=""></p><p>上图中牙签顺时针旋转越多，绳子就绷得越紧。</p><p>OK，大功告成！</p>]]></content>
      
      
        <tags>
            
            <tag> Other </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从 Android 中 Message 的 obj 无法跨进程传送自定义 Parcelable 说起</title>
      <link href="/2018/09/01/%E4%BB%8E%20Android%20%E4%B8%AD%20Message%20%E7%9A%84%20obj%20%E6%97%A0%E6%B3%95%E8%B7%A8%E8%BF%9B%E7%A8%8B%E4%BC%A0%E9%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%20Parcelable%20%E8%AF%B4%E8%B5%B7/"/>
      <url>/2018/09/01/%E4%BB%8E%20Android%20%E4%B8%AD%20Message%20%E7%9A%84%20obj%20%E6%97%A0%E6%B3%95%E8%B7%A8%E8%BF%9B%E7%A8%8B%E4%BC%A0%E9%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%20Parcelable%20%E8%AF%B4%E8%B5%B7/</url>
      <content type="html"><![CDATA[<p>今天温习《Android 开发艺术探索》一书时，看到类似下面这么一句话：「使用 Messenger 将 Message 对象跨进程传输时，obj 属性无法传输自定义的 Parcelable，而只能传输 framework 已有的 Parcelable，比如 Bitmap 等」。然后也翻了源码注释，注释也是这么说的：Froyo 之后，才能用 obj 传输 framework 的 Parcelable，且 obj 不能为 null。下面是注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An arbitrary object to send to the recipient.  When using</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Messenger&#125; to send the message across processes this can only</span></span><br><span class="line"><span class="comment"> * be non-null if it contains a Parcelable of a framework class (not one</span></span><br><span class="line"><span class="comment"> * implemented by the application).   For other data transfer use</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #setData&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that Parcelable objects here are not supported prior to</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> android.os.Build.VERSION_CODES#FROYO&#125; release.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object obj;</span><br></pre></td></tr></table></figure><p>当然，Message 还有 setData(Bundle b) 方法可用，而这个方法中是可以放入自定义的 Parcelable，不过此处需要埋下伏笔。</p><p>下面我们继续说 obj 为什么不能传自定义 Parcelable。理论上说，只有能加载到自定义类，那么就应该能反序列化出自定义类的对象。带着这个想法，我浏览了 Message 的 writeToParcel 和 readFromParcel 两个方法。发现了玄机就是下面的 readFromParcel 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</span><br><span class="line">    what = source.readInt();</span><br><span class="line">    arg1 = source.readInt();</span><br><span class="line">    arg2 = source.readInt();</span><br><span class="line">    <span class="keyword">if</span> (source.readInt() != <span class="number">0</span>) &#123;</span><br><span class="line">        obj = source.readParcelable(getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">    when = source.readLong();</span><br><span class="line">    data = source.readBundle();</span><br><span class="line">    replyTo = Messenger.readMessengerOrNullFromParcel(source);</span><br><span class="line">    sendingUid = source.readInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用 getClass().getClassLoader 来反序列化 obj 所要引用的对象，如果这个 ClassLoader 无法找到自定义类，那么问题肯定就是出在这里了。</p><p>下面我就开始一步一步验证。首先建立一个项目，项目中添加一个自定义的 Parcelable 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mId;</span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Book</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        mId = in.readInt();</span><br><span class="line">        mName = in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        mId = id;</span><br><span class="line">        mName = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后项目中开启两个进程，分别称为 client 进程和 server 进程好了。然后 client 进程的 activity 中绑定 server 进程中的 server，绑定后，client 进程使用 Messenger 向 server 进程发送一个 Message 对象，此 Message 对象的 obj 引用一个 Book 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ServiceConnection mMsgConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">        mMessenger = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Book book = <span class="keyword">new</span> Book(<span class="number">1</span>, <span class="string">"name"</span>);</span><br><span class="line">            mMessenger.send(Message.obtain(<span class="keyword">null</span>, <span class="number">101</span>, book));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我在 Message 类的 readFromParcel 方法中打上断点，当代码执行到断点处时，先验证 getClass().getClassLoader() 无法加载到自定义的 Book 类：</p><p><img src="http://tao93.top/images/2018/09/01/1535789126.png" alt=""></p><p>然后验证主线程的 Thread.getContextClassLoader 可以加载到 Book 类：</p><p><img src="http://tao93.top/images/2018/09/01/1535789156.png" alt=""></p><p>最后验证使用可以加载到 Book 类的 ClassLoader 的话，是可以成功反序列化得到 Book 对象的：</p><p><img src="http://tao93.top/images/2018/09/01/1535789190.png" alt=""></p><p>插一句，这个 readFromParcel 不是运行在主线程，而是运行在 server 进程的 Binder 线程池中的。线程池中的线程的 getContextClassLoader() 结果是 null。</p><p>OK，上面的测试准确的验证了我的想法，现在回到前面说的 Message 的 setData(Bundle b) 方法的伏笔。显然这里的 Bundle 如果要跨进程传输自定义 Parcelable，我们也需要确定 Bundle 在反序列化时不会重蹈 Message.obj 的覆辙。实际上，Bundle 自己做不到这点，还需要我们帮它一把忙，那就是在 server 进程中，从 Message 拿到 Bundle 后再给 Bundle 设置一个 ClassLoader 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">101</span>:</span><br><span class="line">                Bundle b = msg.getData();</span><br><span class="line">                b.setClassLoader(Thread.currentThread().getContextClassLoader());</span><br><span class="line">                Book book = b.getParcelable(<span class="string">"book"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上面de  handleMessage 方法是在主线程，所以我直接使用 Thread.currentThread().getContextClassLoader() 就可以。</p><p>到此，我得出一个结论，那就是我的对于 Java 的 ClassLoader 一无所知，惭愧惭愧，还有很长的路要走。所以，后续我会加强这方面的学习，然后可能会继续加长这篇文章，毕竟这篇的标题是「从 XXX 说起」。</p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python 也能玩跳一跳小游戏</title>
      <link href="/2018/09/01/Python%20%E4%B9%9F%E8%83%BD%E7%8E%A9%E8%B7%B3%E4%B8%80%E8%B7%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
      <url>/2018/09/01/Python%20%E4%B9%9F%E8%83%BD%E7%8E%A9%E8%B7%B3%E4%B8%80%E8%B7%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
      <content type="html"><![CDATA[<p>2017年12月微信发布的跳一跳小游戏，简单却又考验人，借着腾讯一贯的好友排名机制对用户的刺激，几乎是瞬间就火起来了。手残的我，玩这个游戏最多也只有几十分。看着这款小游戏，极其简单的操作 (长按就够了)、极其简单的背景 (几乎是纯色，没有任何背景装饰物)、极其简单的元素 (长方体、圆柱体等)，让我觉得应该可以用一个脚本来自动化玩这个游戏，说干就干。</p><p>对于 Android 设备，需要解决的问题其实只有：模拟长按事件、截图并获取图片、分析图片像素，分析得到每一步需要跳动的距离。下面一样一样来看。</p><p>模拟长按事件，我首先想到了 adb，查了一下，找到了 adb shell input swipe x y time 这样一条命令，swipe 本来是用来做滑动操作的，但是这里只需要长按，所以只提供了一对坐标，最后一个参数 time 表示长按的时间，OK。</p><p>截图并获取图片。获取图片好办，adb pull 一下就好了。截图的话，我也是想到了 adb，查了一下，找到了 adb shell /system/bin/screencap -p /sdcard/screenshot.png 这样的命令，用于截图并放到 sdcard 中的某个位置。</p><p>分析图片像素这一步，就仅仅剩下算法的问题啦，毕竟前面已经拿到了截图了。我是用 Python 的 PIL 图片处理库来做的。我们先来看一张跳一跳的截图：</p><p><img src="http://tao93.top/images/2018/09/01/1535787465.png" alt=""></p><p>首先可以明确一个问题，其实我们不需要求两个落点之间的距离，而只要求上图中两条红色竖线之间的距离就好了，原因是不管往左上跳，还是往有上跳，这两种跳法左右对称，所以每一次跳动的距离，其实正比于两个底座的中心的 x 坐标的距离，也就是上图两条竖直红线的距离。</p><p>假设第一条红色竖线为跳之前位置，第二条竖线为下一个底座中心线。第一条竖线的 x 坐标，可以通过从上到下从左到右扫描图片每一个像素，直到找到了颜色和跳动的棋子颜色相同的颜色 (一种比较深的紫色)。然后就可以找到第一条红线的 x 坐标了。第二条竖线，可以在首次扫描到和背景颜色不一致的颜色时，此时应该就是下一个底座的最靠上的像素，并且由于底座要么是圆柱形要么是长方体，所以这个像素也就是左右方向上是居中的，也就是我们要找的第 2 条竖线的位置。</p><p>最后通过测试和调校，可以找到长按的时长和两条红色竖线距离的比值。</p><p>到此为止，思路都理清了，接下来就是写代码加细节优化了。代码中最外层是个循环，循环的每一步都是这样几步：截图、分析图片确定长按的时长、模拟长按、等待几秒等跳跃完成以免下一次循环过早开始截取到中间态的图片。</p><p>代码如下所示，下面是一个按照 1080P 屏幕写的脚本，还是我去年写的，也不知道是否还适用于现在的跳一跳，我现在也不想玩跳一跳了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def is_ball_color(r, g, b):</span><br><span class="line">    <span class="comment"># 判断是否是棋子顶部小球的颜色</span></span><br><span class="line">    <span class="keyword">if</span> r &lt; 50 or r &gt; 70:</span><br><span class="line">        <span class="built_in">return</span> False</span><br><span class="line">    <span class="keyword">if</span> g &lt; 50 or g &gt; 70:</span><br><span class="line">        <span class="built_in">return</span> False</span><br><span class="line">    <span class="keyword">if</span> b &lt; 50 or b &gt; 70:</span><br><span class="line">        <span class="built_in">return</span> False</span><br><span class="line">    <span class="built_in">return</span> True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def is_base_color(r, g, b):</span><br><span class="line">    <span class="comment"># 判断是否是棋子底座的颜色</span></span><br><span class="line">    <span class="keyword">if</span> r &lt; 50 or r &gt; 70:</span><br><span class="line">        <span class="built_in">return</span> False</span><br><span class="line">    <span class="keyword">if</span> g &lt; 50 or g &gt; 70:</span><br><span class="line">        <span class="built_in">return</span> False</span><br><span class="line">    <span class="keyword">if</span> b &lt; 90 or b &gt; 100:</span><br><span class="line">        <span class="built_in">return</span> False</span><br><span class="line">    <span class="built_in">return</span> True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def is_similar_color(c1, c2):</span><br><span class="line">    <span class="comment"># 判断是否是相近的颜色</span></span><br><span class="line">    <span class="keyword">if</span> abs(c1[0] - c2[0]) &gt; 20:</span><br><span class="line">        <span class="built_in">return</span> False</span><br><span class="line">    <span class="keyword">if</span> abs(c1[1] - c2[1]) &gt; 20:</span><br><span class="line">        <span class="built_in">return</span> False</span><br><span class="line">    <span class="keyword">if</span> abs(c1[2] - c2[2]) &gt; 20:</span><br><span class="line">        <span class="built_in">return</span> False</span><br><span class="line">    <span class="built_in">return</span> True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">    os.system(<span class="string">'adb shell /system/bin/screencap -p /sdcard/screenshot.png'</span>)</span><br><span class="line">    os.system(<span class="string">'adb pull /sdcard/screenshot.png .'</span>)</span><br><span class="line">    img = Image.open(<span class="string">'screenshot.png'</span>)</span><br><span class="line">    w = img.size[0]</span><br><span class="line">    h = img.size[1]</span><br><span class="line">    <span class="keyword">if</span> w == 0 or h == 0:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'w, h:'</span>, w, h)</span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="comment"># print img.getpixel((310, 933))</span></span><br><span class="line">    <span class="comment">#  print img.getpixel((311, 933))</span></span><br><span class="line">    <span class="comment">#  首先是扫描来找棋子</span></span><br><span class="line">    base_x = base_y = 0</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(400, h):</span><br><span class="line">        <span class="comment"># y 坐标从 400 开始，避免扫描到图片顶部的按钮</span></span><br><span class="line">        x = 0</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(0, w):</span><br><span class="line">            px = img.getpixel((x, y))</span><br><span class="line">            <span class="keyword">if</span> is_ball_color(px[0], px[1], px[2]):</span><br><span class="line">                px = img.getpixel((x, y + 192))</span><br><span class="line">                <span class="keyword">if</span> is_base_color(px[0], px[1], px[2]):</span><br><span class="line">                    <span class="built_in">break</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; w - 1:</span><br><span class="line">            base_x = x</span><br><span class="line">            base_y = y</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">    base_y += 192</span><br><span class="line">    <span class="keyword">if</span> base_x == 0:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'base_x == 0'</span>)</span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'base:'</span>, base_x, base_y)</span><br><span class="line">    bg_px = img.getpixel((0, 400))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 然后是扫描来找下一个底座的位置</span></span><br><span class="line">    dest_x = dest_y = 0</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(400, h):</span><br><span class="line">        x = 0</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(0, w):</span><br><span class="line">            <span class="keyword">if</span> x % 50 == 0 and x &gt; 0:</span><br><span class="line">                px = img.getpixel((x - 50, y))</span><br><span class="line">                <span class="keyword">if</span> is_similar_color(bg_px[0 : 3], px[0 : 3]):</span><br><span class="line">                    bg_px = px</span><br><span class="line">                px = img.getpixel((x, y))</span><br><span class="line">                <span class="keyword">if</span> abs(px[0] - bg_px[0]) &gt; 20 or abs(px[1] - bg_px[1]) &gt; 20 or abs(px[2] - bg_px[2]) &gt; 20:</span><br><span class="line">                    <span class="keyword">if</span> abs(x - base_x) &gt; 100:</span><br><span class="line">                        y += 10</span><br><span class="line">                        left = right = x</span><br><span class="line">                        <span class="keyword">while</span> not is_similar_color(bg_px[0 : 3], img.getpixel((left, y))[0 : 3]):</span><br><span class="line">                            left -= 1</span><br><span class="line">                        <span class="keyword">while</span> not is_similar_color(bg_px[0 : 3], img.getpixel((right, y))[0 : 3]):</span><br><span class="line">                            right -= 1</span><br><span class="line">                        <span class="built_in">break</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; w - 1:</span><br><span class="line">            dest_x = (left + right) / 2</span><br><span class="line">            dest_y = y</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line"></span><br><span class="line">    distance = abs(dest_x - base_x)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'dest:'</span>, dest_x, dest_y)</span><br><span class="line">    x = (int)(random.random() * 200 + 600)</span><br><span class="line">    y = (int)(random.random() * 200 + 600)</span><br><span class="line">    <span class="comment"># t 是长按的时间</span></span><br><span class="line">    t = distance * 600 / 383</span><br><span class="line">    loc = <span class="string">' '</span> + str(x) + <span class="string">' '</span> + str(y) + <span class="string">' '</span></span><br><span class="line">    os.system(<span class="string">'adb shell input swipe '</span> + loc + loc + str(t))</span><br><span class="line">    os.system(<span class="string">'rm screenshot.png'</span>)</span><br><span class="line">    time.sleep(3)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>macOS 系统编译 Android 8.1.0 源码全过程</title>
      <link href="/2018/09/01/macOS%20%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91%20Android%208.1.0%20%E6%BA%90%E7%A0%81%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/09/01/macOS%20%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91%20Android%208.1.0%20%E6%BA%90%E7%A0%81%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>这篇文章详细记录我在 macOS 10.13 上使用 AOSP 代码编译最新 Android 8.1.0 的 userdebug 系统，并安装到 Pixel XL 手机上，最后用 AOSP 代码成功调试 userdebug 系统 (从而可以准确将电脑上的源码和设备系统代码行号对应) 的全过程。全文包括 AOSP 的获取、编译 Android 系统、使用 Intellij IDEA 打开部分源码、使用 Intellij IDEA 进行调试这样几部分。</p><p>环境：macOS 10.13, 250GB SSD, 16GB RAM, XCode 9.2, JDK 1.8.0_151</p><p>###一、AOSP 代码的获取</p><p>因 Android 的编译需要 case-sensitive 的磁盘系统，而 macOS 的磁盘系统不满足此条件，所以我们需要建立一个 case-sensitive 的镜像文件，然后挂载此镜像文件，最后再挂载的目录中获取源码和编译源码。建立镜像文件的操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建空间上限为 150GB 的稀疏镜像文件，创建后镜像文件其实是 ~/android.dmg.sparseimage </span></span><br><span class="line"><span class="comment"># 创建后并未真正占据这么多磁盘空间，而是随着镜像中防止的数据越来越多，该镜像文件才原来越大 </span></span><br><span class="line">hdiutil create -<span class="built_in">type</span> SPARSE -fs <span class="string">'Case-sensitive Journaled HFS+'</span> -size 150g ~/android.dmg </span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后就可以将镜像文件挂载到 /Volumes 中，比如我挂载到 /Volumes/android </span></span><br><span class="line">hdiutil attach ~/android.dmg.sparseimage -mountpoint /Volumes/android </span><br><span class="line"></span><br><span class="line"><span class="comment"># 解除挂载则是下面这样 </span></span><br><span class="line">hdiutil detach /Volumes/android </span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像文件的空间上限是可以更改的，比如下面更改为 160GB </span></span><br><span class="line">hdiutil resize -size 160G ~/android.dmg.sparseimage</span><br></pre></td></tr></table></figure><p>提示一下，hdiutil 命令的某些操作需要电脑插着电源，否则会报错，不过这个报错在 Google 搜索一下就能找到答案了。</p><p><a href="https://source.android.com/" target="_blank" rel="noopener">AOSP 项目</a>因为包含太多了子项目，所以每个子项目使用 Git 来管理，而整个 AOSP 则使用 repo 工具来管理，repo 其实就是一个 shell 脚本，内部调用 Git。官文提供的<a href="https://source.android.com/setup/downloading" target="_blank" rel="noopener">获取 AOSP 代码</a>的方式因为某些原因而比较难做到，所以我<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/aosp" target="_blank" rel="noopener">从 USTC Mirror 来获取源码</a>。步骤如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先获取一下 repo 工具 </span></span><br><span class="line">mkdir ~/bin <span class="built_in">export</span> PATH=~/bin:<span class="variable">$PATH</span> </span><br><span class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo </span><br><span class="line"></span><br><span class="line"><span class="comment"># 先挂载，然后进入挂载后的目录，创建一个目录，我这是创建了 android-8.1.0_r20 </span></span><br><span class="line"><span class="built_in">cd</span> /Volumes/android </span><br><span class="line">mkdir android-8.1.0_r20 &amp;&amp; <span class="built_in">cd</span> android-8.1.0_r20 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后使用 repo init 来初始化 AOSP 目录，因为 android-8.1.0_r20 是可以安装在 Pixel XL 上面的最新版本，所以我选择它来作为分支 </span></span><br><span class="line"><span class="comment"># 参见 https://source.android.google.cn/setup/build-numbers?hl=zh-cn#source-code-tags-and-builds 来查询哪些分支支持哪些设备。 </span></span><br><span class="line"><span class="comment"># USTC Mirror 作为同步代码的镜像 </span></span><br><span class="line">repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest -b android-8.1.0_r20 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来是需要漫长时间的一步，即从服务器同步所有代码及文件到本地。 </span></span><br><span class="line">repo sync</span><br></pre></td></tr></table></figure><p>如果 repo init 失败，可以参考一下 <a href="https://lug.ustc.edu.cn/wiki/mirrors/help/aosp#%E5%88%9D%E5%A7%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%952" target="_blank" rel="noopener">USTC Mirror 的方法</a> 中的初始化仓库那一步。同步过程是可能意外中断的，此时可以直接继续执行 repo sync 来继续同步。不过，这个补刀是可以自动化执行的，那就是下面的 shell 脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line">repo sync </span><br><span class="line"><span class="keyword">while</span> [ $? -e 1 ]; <span class="keyword">do</span> </span><br><span class="line">    repo sync </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> success</span><br></pre></td></tr></table></figure><p>除了同步的方式，其实还有另一条路可以走，那就是先从 USTC Mirror AOSP Monthly 或者 TUNA Mirror AOSP Monthly 下载 aosp-latest.tar 文件，然后解压到放置源码的目录，然后再 repo init，然后再 repo sync，这样的话，repo sync 就会快很多，可能一个小时就可以了吧。</p><h3 id="二、编译-Android-系统"><a href="#二、编译-Android-系统" class="headerlink" title="二、编译 Android 系统"></a>二、编译 Android 系统</h3><p>成功得到源码后，就可以编译 Android 系统镜像了。在 macOS 上，如果你不是 macOS 或 iOS 开发者的话，八成我们需要先安装 XCode。</p><p>Gentle remind：加入你也是 250GB SSD 用户，考虑到编译过程中，源码目录占据的空间会越来越庞大，那么我建议暂时将源码根目录中的 .repo 隐藏目录剪切到移动硬盘。但是光这样还不够，你还需要先解除挂载，然后再执行下面的命令来收缩稀疏镜像文件所占据的空间大小：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为稀疏镜像文件删除内容时，并不会减小占据的空间大小，所以稀疏镜像文件会越来越大，解决办法就是下面这样收缩一下 </span></span><br><span class="line"><span class="comment"># 收缩是把稀疏镜像中没有使用的空间去除掉，从而让它不那么稀疏，就好像把海绵里的水挤掉一样 </span></span><br><span class="line">hdiutil compact android.dmg.sparseimage</span><br></pre></td></tr></table></figure><p>下面开始编译的一些步骤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先进入 AOSP 根目录，然后尝试执行下面的命令，也就是清理上次构建的产物 </span></span><br><span class="line">make clobber</span><br></pre></td></tr></table></figure><p>如果上面的命令报错，提示 MacOSX SDK 缺少，那么可以 <a href="https://github.com/phracker/MacOSX-SDKs/releases" target="_blank" rel="noopener">https://github.com/phracker/MacOSX-SDKs/releases</a> 下载对应版本的压缩包，解压到 /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs 这个路径中。如果提示什么 rt.jar 找不到，那么久将 ANDROID_JAVA_HOME 设置为 JDK 的根目录。</p><p>直到 make clobber 不报错了，开始下面的步骤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引入一个环境设置的脚本 </span></span><br><span class="line"><span class="built_in">source</span> build/envsetup.sh </span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择编译目标，我选择的是 aosp_marlin-userdebug，marlin 表示 Pixel XL，userdebug 的含义表示调试版本的 Android 系统 </span></span><br><span class="line">lunch </span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后就是开始编译了，-j 后面表示多少个线程并行编译。根据电脑 CPU 硬件来选，一般 4 核心 8 线程的 CPU 就选 -j8 </span></span><br><span class="line">make -j8</span><br></pre></td></tr></table></figure><p>完整编译一遍是需要耗费若干小时时间的，所以耐心等待，我的电脑是 MacBook Pro 15 寸 2016版 2.6GHz CPU，编译大约需要三四个小时。</p><p>如果上面编译时出现类似下面的错误：</p><blockquote><p>ninja: build stopped: subcommand failed.</p><p>ninja failed with: exit status 1</p></blockquote><p>那么参考 <a href="https://groups.google.com/forum/#!topic/android-building/D1-c5lZ9Oco" target="_blank" rel="noopener">https://groups.google.com/forum/#!topic/android-building/D1-c5lZ9Oco</a> 给出的方法，需要更改 external/bison 这个项目的代码了。此时如果前面我们把 .repo 隐藏目录剪贴走了，那么现在就需要把它的一部分拷贝回来，即 external/bison 这个项目所需的 Git track 文件，通过查看 external/bison/.git 中的符号链接，我们可以知道哪些文件需要拷贝回来。</p><p><img src="http://tao93.top/images/2018/09/01/1535786626.png" alt=""></p><p>红框中就是需要拷贝回来的目录。然后我们执行下面的更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先进入这个 bison 项目的目录 </span></span><br><span class="line"><span class="built_in">cd</span> external/bison </span><br><span class="line"></span><br><span class="line"><span class="comment"># 作出更改 </span></span><br><span class="line">git cherry-pick c0c852bd6fe462b148475476d9124fd740eba160 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建一下 bison 项目 </span></span><br><span class="line">mm </span><br><span class="line"></span><br><span class="line"><span class="comment"># 回到 AOSP 根目录，然后将刚刚构建得到的 bison 替代另一个地方的 </span></span><br><span class="line"><span class="built_in">cd</span> ../.. &amp;&amp; cp out/host/darwin-x86/bin/bison prebuilts/misc/darwin-x86/bison/ </span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后继续再编译 </span></span><br><span class="line">make -j8</span><br></pre></td></tr></table></figure><p>建议：如果你也是 250 GB SSD 用户，那么每次编译失败后，可以先 make clobber 清除构建产物，再解除挂载，然后 compat 一下稀疏镜像文件，这样可以尽可能的避免最后编译时空间不够用。</p><h3 id="三、烧录到-Pixel-XL-设备中"><a href="#三、烧录到-Pixel-XL-设备中" class="headerlink" title="三、烧录到 Pixel XL 设备中"></a>三、烧录到 Pixel XL 设备中</h3><p>先进入开发者模式，然后打开 OEM 锁。连接到电脑，使用 adb reboot bootloader 命令让手机进入到 BootLoader 模式，当然也可以采用按设备的物理按键的方式进入 BootLoader 模式。如果此时屏幕下像下面这样，就不需要解锁，反之需要使用 fastboot flashing unlock 来解开 BootLoader 锁。糟了，今天出门没带手机，无法截图了，反正就是屏幕下部出现 unlocked 字样，然后还有一把解开的小锁的图标，就是已解锁，否则是未解锁。只有解锁后才能刷机。对了，温馨提示一下，解锁后每次开机都会提示「Your device software can’t be checked for corruption. Please lock the bootloader. PRESS POWER TO PAUSE BOOT」，不用理它就好了。</p><p>现在我们要去 <a href="https://developers.google.com/android/drivers" target="_blank" rel="noopener">Driver Binaries</a> 下载适用于 Pixel XL 的驱动文件。这个页面很长，要在其中找到我们需要的驱动文件，需要一个细分版本号，在 <a href="https://source.android.com/setup/start/build-numbers" target="_blank" rel="noopener">代号、标签和版本号</a>这个页面，可以找到我之前使用的 android-8.1.0_r20 分支对应的细分分支是 OPM2.171019.029，使用这个细分分支，就可以在 <a href="https://developers.google.com/android/drivers" target="_blank" rel="noopener">Driver Binaries</a> 下载到用于 Pixel XL 的准确的驱动文件了，如下图所示，一共是两个文件，下载之后解压，发现是两个 shell 脚本，名字分别是 extract-qcom-marlin.sh 和 extract-google_devices-marlin.sh。</p><p><img src="http://tao93.top/images/2018/09/01/1535786865.png" alt=""></p><p>现在，将上一步得到的两个 shell 脚本都复制到 AOSP 源码根目录，然后分别执行以下。接下来，需要以下步骤来编译得到一些额外的文件，其实我也不知道是什么文件。接下来的步骤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> build/envsetup.sh </span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面这一步我依旧是选 marlin-userdebug </span></span><br><span class="line">lunch</span><br><span class="line">make -j8</span><br></pre></td></tr></table></figure><p>别担心上面这个 make 很快就会完成，因为之前已经完整编译过了。接下来要开始刷机的最后步骤了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为后面的 flashall 需要下面这样一个环境变量，所以先设置一下 </span></span><br><span class="line"><span class="built_in">export</span> ANDROID_PRODUCT_OUT=&lt;AOSP_ROOT_DIR&gt;/out/target/product/marlin </span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入上面这个 marlin 目录，手机保持 BootLoader 模式并连接到电脑，然后开始刷机</span></span><br><span class="line">fastboot -w flashall</span><br></pre></td></tr></table></figure><h3 id="四、调试-Android-代码"><a href="#四、调试-Android-代码" class="headerlink" title="四、调试 Android 代码"></a>四、调试 Android 代码</h3><p>user-debug 的系统安装到手机中后，可以发现和发行版还是有些不同的，比如没有 Google 框架，没有 Google Photos，甚至连时钟应用都和发行版的原生 Android 不一样。如果需要调试代码，比如我们调试到 com.android.internal.policy.PhoneWindow 这个类的代码，那么显然，需要使用一个 IDE 来打开我下载的 AOSP 源码，因为这份源码再是安装到手机中的源码，而不能使用 Android SDK 中的 sources/android-27 中的源码来调试。使用 Intellij IDEA (下面用 IDEA 简称) 来打开源码，将会比 Android Studio 好一些，因为前者更容易控制 JDK 的引入。</p><p>首先，对于我们的个人电脑来说，直接打开整个 AOSP 项目的源码显得有些考验人，同时也考验机。因为 AOSP 目录太庞大了，IDEA 建立索引将会需要非常之久，一旦文件有了更改，重新索引又要很久，此外，光是索引文件都会很大。所以权宜之计是，只把最常用的一部分 AOSP 代码 (也就是一部分子项目) 使用 IDEA 打开。我选择了 framework 目录下的所有子项目和 libcore、repo 这两个子项目。framework 是因为里面的代码常用到，libcore 是因为里面有 Java 的库代码，而 repo 是因为 repo 被引用了，所以也加进来了。</p><p>此外，因为 AOSP 源码放置在 case-sensitive 的镜像文件中，而如果 IDEA 打开位于镜像文件中的源码的话，将需要为 IDEA 配置为 case-sensitive，可是 IDEA 可能还需要打开其他的普通项目，即位于 macOS 的 case-insensitive 文件系统中的项目。这样两者就会冲突，频繁报错。所以我的方法是，把上一段提到的部分子项目拷贝到外面，也就是拷贝到 macOS 文件系统，然后再用 IDEA 打开。</p><p>接下来是具体的步骤了， 首先需要生成用于 IDEA 的 android.imp 和 android.ipr 文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 AOSP 根目录执行下面的命令 </span></span><br><span class="line">make idegen &amp;&amp; development/tools/idegen/idegen.sh</span><br></pre></td></tr></table></figure><p>然后就是拷贝子项目出来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个 aosp_part 就是用来保存部分子项目的目录了 </span></span><br><span class="line">mkdir aosp_part &amp;&amp; <span class="built_in">cd</span> aosp_part </span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝 framework 目录和 libcore 目录出来 </span></span><br><span class="line">cp -R /Volumes/android/android-8.1.0_r20/framework . </span><br><span class="line">cp -R /Volumes/android/android-8.1.0_r20/libcore . </span><br><span class="line">cp -R /Volumes/android/android-8.1.0_r20/repo .</span><br></pre></td></tr></table></figure><p>为避免不小心改动上面项目中的文件，我们需要 Git 来追踪它们，而所有子项目的 git 文件其实都在 .repo 这个隐藏目录中。所以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 接下来需要把上面子项目对应的 .git 目录拷贝过来 </span></span><br><span class="line"><span class="comment"># 先建一个 .repo 目录，并建好相关目录 </span></span><br><span class="line">mkdir -p .repo/project-objects/platform &amp;&amp; mkdir -p .repo/projects </span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后开始拷贝 .git 目录 </span></span><br><span class="line">cp -R /Volumes/android/android-8.1.0_r20/.repo/project-objects/platform/frameworks .repo/project-objects/platform </span><br><span class="line">cp -R /Volumes/android/android-8.1.0_r20/.repo/project-objects/platform/libcore.git .repo/project-objects/platform </span><br><span class="line">cp -R /Volumes/android/android-8.1.0_r20/.repo/project-objects/platform/repo.git .repo/project-objects/platform </span><br><span class="line">cp -R /Volumes/android/android-8.1.0_r20/.repo/projects/frameworks .repo/projects/ cp -R /Volumes/android/android-8.1.0_r20/.repo/projects/libcore.git .repo/projects/ </span><br><span class="line">cp -R /Volumes/android/android-8.1.0_r20/.repo/projects/repo.git .repo/projects/ </span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后，把前面生成的两个文件拷贝过来 </span></span><br><span class="line">cp /Volumes/android/android-8.1.0_r20/android.iml /Volumes/android/android-8.1.0_r20/android.ipr .</span><br></pre></td></tr></table></figure><p>然后，就可以使用 IDEA 以打开项目的形式打开此 aosp_part 目录了。打开后，因为 libcore 中就已经有了 JDK 库代码，所以我们需要让 aosp_part 项目不使用电脑中的 JDK。方法是在 IDEA 打开的 aosp_part 项目，File → Project Structure → SDKs，然后如下图所示：</p><p><img src="http://tao93.top/images/2018/09/01/1535787196.png" alt=""></p><p>点击加号，新建一个 JDK 并将新的 JDK 命名为 aosp_jdk_1.8，新建的 JDK 一开始会和已有的那个 JDK 1.8 一模一样，包含了库代码，所以我们需要把 aosp_jdk_1.8 的 ClassPath tab 中的所有 .jar 文件移除，这样 aosp_jdk_1.8 成了一个空的 JDK，将被用于 aosp_part 项目，而其他的 IDEA 项目可以依旧使用 JDK 1.8，互不影响。</p><p>在上面的窗口中，在左侧切换到 Modules tab，然后如下图，切换到 dependencies tab：</p><p><img src="http://tao93.top/images/2018/09/01/1535787229.png" alt=""></p><p>在上面这个界面会有非常多的 .jar ，把它们全部移除，然后再添加前面那个 aosp_jdk_1.8，现在就已经用 IDEA 打开了部分 android 源码了：</p><p><img src="http://tao93.top/images/2018/09/01/1535787252.png" alt=""></p><p>接下来是最后一步了，在 IDEA 中调试代码。</p><p>在 IDEA 中，Run → Edit Configuration → + → Remote，然后编辑一下 name，然后把 Settings 下面的 port 编辑为 8700，最后保存。</p><p>在 Android SDK 源码目录中的 tools 目录中的 monitor 可执行文件。如果这个程序打不开，别担心，先检查一下 JDK 版本是不是高于或等于 1.8.0_152，如果是，那么只需要回退到 1.8.0_151 即可。贴心的我提供一份 JDK 1.8.0_151 的下载地址，在这里找到 1.8.0_151 版本即可以。</p><p>打开 monitor 后，鼠标选中需要调试的进程：</p><p><img src="http://tao93.top/images/2018/09/01/1535787290.png" alt=""></p><p>因为今天没带手机，所以上图中是个 vivo 的测试机。</p><p>然后在 IDEA 点击调试按钮 (图标是一个绿色的小虫子)，此时如果弹出 Debug tool window 并提示 connected to target VM，则说明可以加断点调试了。</p><p><img src="http://tao93.top/images/2018/09/01/1535787316.png" alt=""></p><p>EOF</p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> AOSP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 执行远程脚本</title>
      <link href="/2018/09/01/Linux%20%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%84%9A%E6%9C%AC/"/>
      <url>/2018/09/01/Linux%20%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%84%9A%E6%9C%AC/</url>
      <content type="html"><![CDATA[<p>最近工作上需要写一套跨服务器分隔数据和转移数据的脚本。经过实践，发现单纯执行在本地执行命令来操控远程服务器的数据不现实。所以需要把脚本放在远程服务器，然后本地让服务器自己去执行脚本。此外，需要使用 expect 工具来自动输入远程服务器登录密码。</p><p>先提一些  expect 的用法，即可以写成 expect 脚本形式 (即脚本以 #!/usr/bin/expect 开头)，也可以写成 expect -c ‘&lt;several_cmd&gt;’ 的单条命令形式。后者的示例形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect -c <span class="string">'spawn scp root@example:~/xx.txt .; expect "password:"; send "abc1234\\r"; interact;'</span></span><br></pre></td></tr></table></figure><p>上面例子中，spawn 后面表示需要执行的命令 (此处是一个 scp 命令，需要输入密码，这就是为什么要 expect 的原因)，expect 后面是表示标准输出出现 “password:” 字样时，就自动输入 send 后面的东西，也就是密码。最后一个 interact 表示接下来允许用户自己交互。</p><p>本来直接使用 shell 脚本就可以的。不过我这设计到数据的切割，所以就使用了 Python，然后需要用到 shell 命令时，是由 Python 脚本再调用 shell 命令的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_remote_cmd</span><span class="params">(host, password, cmd)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    让远程服务器自己执行命令 </span></span><br><span class="line"><span class="string">    :param host: 远程服务器用户名加域名，格式示例：root@example.com </span></span><br><span class="line"><span class="string">    :param cmd: 要让远程服务器执行的命令 </span></span><br><span class="line"><span class="string">    :return: 一些结果，其中可能有一些提示性文本</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 举个例子，ssh root@example.com ls 可以让远程服务器执行 ls 命令</span></span><br><span class="line">    final_cmd = <span class="string">'/usr/bin/expect -c \'spawn ssh %s %s; expect "*Password:"; send "%s\\r"; interact;\''</span> % (host, cmd, password)</span><br><span class="line">    res = os.popen(final_cmd).read()</span><br><span class="line">    print(res)</span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传给远程服务器上的 Python 脚本作为参数 </span></span><br><span class="line">args = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># args 需要经过复杂的替换，才能保证准确传递到远程服务器的 Python 脚本中</span></span><br><span class="line">args = str(args) </span><br><span class="line">args = args.replace(<span class="string">'\''</span>, <span class="string">'\\\"'</span>)</span><br><span class="line">args = args.replace(<span class="string">' '</span>, <span class="string">'\\ '</span>) </span><br><span class="line">args = args.replace(<span class="string">','</span>, <span class="string">'\\,'</span>) </span><br><span class="line">args = args.replace(<span class="string">'['</span>, <span class="string">'\\['</span>) </span><br><span class="line">args = args.replace(<span class="string">']'</span>, <span class="string">'\\]'</span>) </span><br><span class="line">args = args.replace(<span class="string">'&#123;'</span>, <span class="string">'\\&#123;'</span>) </span><br><span class="line">args = args.replace(<span class="string">'&#125;'</span>, <span class="string">'\\&#125;'</span>) </span><br><span class="line">args = args.replace(<span class="string">';'</span>, <span class="string">'\\;'</span>) </span><br><span class="line">args = args.replace(<span class="string">'"'</span>, <span class="string">'\\"'</span>) </span><br><span class="line"></span><br><span class="line">cmd = <span class="string">'/usr/local/bin/python3 x.py \\"%s\\"'</span> % args </span><br><span class="line">call_remote_cmd(<span class="string">'root@example.com'</span>, <span class="string">'password'</span>, cmd)</span><br></pre></td></tr></table></figure><p>上面是我因工作需要而写出来的让远程服务器执行它的 Python 脚本的本地 Python 脚本代码。使用的时候就简单了。服务器上面放一个被调用的 Python 脚本。然后执行上面代码，就可以了。</p><p>想必直接写 shell 脚本的话，可能会更简洁些。等啥时候有空了试试看。</p>]]></content>
      
      
        <tags>
            
            <tag> Shell </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Homebrew 小结</title>
      <link href="/2018/09/01/Homebrew%20%E5%B0%8F%E7%BB%93/"/>
      <url>/2018/09/01/Homebrew%20%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>说实话，我无法适应暗色背景的界面，比如 jetbrains 系列 IDE 的 Darcula 主题 (暗色的背景)，再比如 Terminal 的一些暗色背景主题，所以我也无法直视 <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a> 主页的背景色，看得我眼睛难受。但是，Homebrew 应该是一个很不错的工具，毕竟它几乎取代了 MacPorts。</p><p>Homebrew 是 macOS 上的一款包管理工具，作用类似于 Ubuntu 上面的 apt-get。不同点是，Homebrew 的操作不需要 root 权限，Homebrew 不是系统级别的工具。Homebrew 维护一些称为 tap 的 git repository，每个 tap 里面是一些 formula，所谓的 formula 就是对应一个软件包（比图 wget 和 git 就是两个 formula）。最重要的 tap 是 homebrew/core，这个 tap 也是自带的，其中是各种命令行工具，它在安装了 Homebrew 的系统中一般位于 /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core，这可以通过 brew –repo homebrew/core 得知：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  Downloads brew --repo homebrew/core</span><br><span class="line">/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core</span><br><span class="line">➜  Downloads cd /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core</span><br><span class="line">➜  homebrew-core git:(master)</span><br></pre></td></tr></table></figure><p>从上面可知 homebrew/core 这个 tap 在本地是一个 git 项目，实际上里面维护了四千多个 formula，也就是可供用户安装 4000 多个命令行工具，每个 formula 都是用一个 ruby 文件描述的。此外，还有 homebrew/science 和 homebrew/php 等官方 tap。除了官方 tap 外，还有著名的 caskroom/cask 这个用来安装 gui 软件(例如 Sublime Text)的 tap。插一句，在 caskroom 的 tap 中，不是用 formula 表示软件包，而是用 cask 来表示，所以大致可以认为 formula 表示命令行的包，而 cask 表示 gui 软件。对用户来说，Homebrwe 可以做的事就是搜索、安装、升级、查看、卸载各种软件包，此外也可以管理增删 tap。</p><p>除了 homebrew/core 外，我只添加了 caskroom/cask 这一个 tap。要添加此 tap 或移除它，只需要执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加 </span></span><br><span class="line">brew tap caskroom/cask </span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 </span></span><br><span class="line">brew untap caskroom/cask</span><br></pre></td></tr></table></figure><p>当长时间没有更新过 tap 对应的本地 git 项目，那么下一次更新时，因为国内的网络环境，更新所需要的时间可能要很久，所以我使用了 USTC Mirror 的 <a href="http://mirrors.ustc.edu.cn/help/brew.git.html" target="_blank" rel="noopener">Homebrew 代理</a>。具体方法其实就是，把 homebrew/core 和 caskroom/cask 这两个 tap 对应的本地 git 项目的 remote url 分别设置为 <a href="https://mirrors.ustc.edu.cn/homebrew-core.git" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/homebrew-core.git</a> 和 <a href="https://mirrors.ustc.edu.cn/homebrew-cask.git，这样更新就很快了。另外，brew" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/homebrew-cask.git，这样更新就很快了。另外，brew</a> 下载软件是从一个所谓的 bootle 去下载 (这个 bootle 的 URL 是 <a href="https://homebrew.bintray.com/，其实就是里面托管了非常多常见的软件的压缩包" target="_blank" rel="noopener">https://homebrew.bintray.com/，其实就是里面托管了非常多常见的软件的压缩包</a>) 或者从软件的官网去下载。具体在哪里下载，则是根据 formula 的 ruby 描述文件中的描述来定的。</p><p>那有没有上面说的这个 bottle 的镜像以便可以快速下来软件呢？当然有，同样是来自于 USTC Mirror 的，做法很简单，设置一个环境变量 HOMEBREW_BOTTLE_DOMAIN，其值为 <a href="https://mirrors.ustc.edu.cn/homebrew-bottles" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/homebrew-bottles</a> 即可。</p><p>下面是这一通修改对应的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切到 homebrew/core 对应的 git 项目目录 </span></span><br><span class="line"><span class="built_in">cd</span> $(brew --repo homebrew/core) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 换 url </span></span><br><span class="line">git remote <span class="built_in">set</span>-url origin https://mirrors.ustc.edu.cn/homebrew-core.git </span><br><span class="line"></span><br><span class="line"><span class="comment"># same as previous </span></span><br><span class="line"><span class="built_in">cd</span> $(brew --repo caskroom/cask) </span><br><span class="line"></span><br><span class="line"><span class="comment"># same as previous </span></span><br><span class="line">git remote <span class="built_in">set</span>-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git </span><br><span class="line"></span><br><span class="line"><span class="comment"># 我是使用 zsh，所以追加到 .zshrc 末尾就可以，如果是使用 bash，则不能这样 </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles'</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><p>下面开始是 brew 的一些常用命令小结。</p><p><strong>brew search \&lt;formulaName>:</strong></p><p>在已安装 tap 中查找包，搜索到的结果类似如果不是 homebrew/core 这个 tap 中的，将会以 tapName/formulaName 的形式列出。例如 brew search git 的结果大致是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bagit</span><br><span class="line">bash-git-prompt</span><br><span class="line">...</span><br><span class="line">git</span><br><span class="line">...</span><br><span class="line">caskroom/cask/git-it</span><br></pre></td></tr></table></figure><p><strong>brew install \&lt;formuaName>:</strong></p><p>安装指定 formula 的最新版本，安装路径一般是 /usr/local/Cellar/<formulaname>/<versionnumber> 中，此外会在 /usr/local/bin 中建立指向可执行文件的符号链接，以便命令行直接运行。</versionnumber></formulaname></p><p><strong>brew uninstall formulaName:</strong></p><p> 卸载指定 formula，不过不会删除安装包文件。</p><p><strong> brew upgrade formulaName:</strong></p><p>升级指定的 formula 到最新版。</p><p><strong>brew cleanup:</strong></p><p>在安装了更新版本软件包后，从 /usr/local/Cellar 删除旧版本的软件包。没错，升级时并不是覆盖式安装，而是在 /usr/local/Cellar/<formulaname> 中多了一个更高版本号的目录，然后符号链接指向更高版本目录中的可执行文件。所以，如果不想要这种冗余，就可以用 brew cleanup 来清除旧版本的目录。</formulaname></p><p><strong>brew outdated:</strong></p><p>查看哪些 formula 可以升级。</p><p><strong>brew info formulaName:</strong></p><p>查看 formula 的信息，例如 brew info git, brew info caskroom/cask/git-it 等。</p><p><strong>brew update:</strong></p><p>更新所有 tap 中的包信息，其实也就是把每个 tap 对应的本地 git 项目更新到服务器最新提交，以便可以搜索到最新添加的包以及已有包的最新发布信息。</p><p><strong>brew list:</strong></p><p>列出已安装的所有包。</p><h3 id="tap-的管理："><a href="#tap-的管理：" class="headerlink" title="tap 的管理："></a>tap 的管理：</h3><p><strong>brew tap tapName:</strong></p><p>新增一个 tap。</p><p><strong>brew untap tapName:</strong></p><p>移除一个 tap。</p><p><strong>brew tap-info tapName:</strong></p><p>列出一个 tap 的详细信息。</p><p>更多操作，可以参考<a href="https://github.com/Homebrew/brew/blob/master/docs/Manpage.md" target="_blank" rel="noopener">官方文档</a>，内容很全面。</p>]]></content>
      
      
        <tags>
            
            <tag> Homebrew </tag>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HomeBrew Cask 加快下载的脚本</title>
      <link href="/2018/09/01/HomeBrew%20Cask%20%E5%8A%A0%E5%BF%AB%E4%B8%8B%E8%BD%BD%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
      <url>/2018/09/01/HomeBrew%20Cask%20%E5%8A%A0%E5%BF%AB%E4%B8%8B%E8%BD%BD%E7%9A%84%E8%84%9A%E6%9C%AC/</url>
      <content type="html"><![CDATA[<p>Homebrew 是个好工具，除了用它安装命令行软件外，我也会用它来安装 GUI 软件。这么做的好处是 Homebrew 会直接帮我接连链接到 GUI 软件的可执行文件的符号链接，这样，我在终端使用符号链接，就可以打 GUI 软件了。例如，Sublime Text 的符号链接是 subl，那么在终端任何目录中，一行 subl “new text.txt” 就可以用 Sublime Text 打开new text.txt了。</p><p>问题是，brew cask install xxx 的下载速度经常会非常慢，而我把下载软件包的 URL 直接复制到 Chrome 中去下载，则非常快，这就很尴尬了。经过稍微检查，我发现brew cask install xxx 过程中，会在 Cache/Cask 目录(其实就是 brew –cache命令的结果)中生成一个类似于xxx–v1.2.3.zip.incomplete这样的文件。于是我把自己用 Chrome 下载的文件，复制到 Cache/Cask 中来，然后更名为 xxx–v1.2.3.zip，也就是把 .incomplete 去掉。然后再 brew cask install xxx一下，发现 Homebrew 提示软件包已经下载好了，于是立刻开始安装了。</p><p>上面这样的方式确实避免了下载慢的问题，不过这样手动操作，总是不那么高(yǒu)效(bī)率(gé)，所以我就想要写个小脚本来自动化这个过程。我选择了使用 shell 脚本。此处要吐槽一下 shell 脚本的语法，难记，真的是很难记(比如字符串操作)！比起来，几乎任何一门编程语言的语法都要好记得多。</p><p>废话说了很多了，下面是脚本内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$#</span>"</span> -eq <span class="string">"1"</span> ]; <span class="keyword">then</span> </span><br><span class="line">    <span class="comment"># 找到本地描述需要安装的软件包的 ruby 文件 </span></span><br><span class="line">    tap_path=`brew --repo caskroom/cask` </span><br><span class="line">    file_path=<span class="string">"<span class="variable">$&#123;tap_path&#125;</span>/Casks/<span class="variable">$&#123;1&#125;</span>.rb"</span> </span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="string">"<span class="variable">$file_path</span>"</span> ]; <span class="keyword">then</span> </span><br><span class="line">        <span class="comment"># 从里面读取版本信息，下载的 URL </span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">read</span> key value; <span class="keyword">do</span> </span><br><span class="line">            <span class="keyword">if</span> [[ <span class="variable">$key</span> == <span class="string">"version"</span> ]]; <span class="keyword">then</span> </span><br><span class="line">                len=$((<span class="variable">$&#123;#value&#125;</span>-2)) </span><br><span class="line">                version=<span class="variable">$&#123;value:1:$&#123;len&#125;</span>&#125; </span><br><span class="line">            <span class="keyword">elif</span> [[ <span class="variable">$key</span> == <span class="string">"url"</span> ]]; <span class="keyword">then</span> </span><br><span class="line">                len=$((<span class="variable">$&#123;#value&#125;</span>-2)) </span><br><span class="line">                url=<span class="variable">$&#123;value:1:$&#123;len&#125;</span>&#125; </span><br><span class="line">                url=<span class="variable">$&#123;url/\#\&#123;version\&#125;</span>/<span class="variable">$version</span>&#125; </span><br><span class="line">                <span class="comment"># 使用 Chrome 来下载 </span></span><br><span class="line">                /Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome <span class="variable">$url</span> </span><br><span class="line">            <span class="keyword">fi</span> </span><br><span class="line">        <span class="keyword">done</span> &lt; <span class="variable">$file_path</span> </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Cask '<span class="variable">$1</span>' is unavailable: No Cask with this name exists."</span> </span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    cache_dir=`brew --cache`</span><br><span class="line">    downloaded_name=<span class="variable">$&#123;url##*/&#125;</span></span><br><span class="line">    target_name=<span class="variable">$1</span>--<span class="variable">$&#123;version&#125;</span>.<span class="variable">$&#123;downloaded_name##*.&#125;</span> </span><br><span class="line">    <span class="comment"># 每个三秒钟检查一下下载好了没，好了就把下载好的文件移动到 </span></span><br><span class="line">    <span class="comment"># Cache/Cask 中，并且改名为 Homebrew 想要的方式。 </span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> </span><br><span class="line">        <span class="keyword">if</span> [ -e ~/Downloads/<span class="variable">$downloaded_name</span> ]; <span class="keyword">then</span> </span><br><span class="line">            mv ~/Downloads/<span class="variable">$downloaded_name</span> <span class="variable">$cache_dir</span>/Cask/<span class="variable">$target_name</span> </span><br><span class="line">            <span class="comment"># 安装 </span></span><br><span class="line">            brew cask install <span class="variable">$1</span> </span><br><span class="line">            <span class="built_in">break</span> </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sleep 3 </span><br><span class="line">        <span class="keyword">fi</span> </span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"usage: cask-install Cask-Name"</span> </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Homebrew </tag>
            
            <tag> Shell </tag>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Touch 事件的传递与处理</title>
      <link href="/2018/08/30/Android%20Touch%20%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E9%80%92%E4%B8%8E%E5%A4%84%E7%90%86/"/>
      <url>/2018/08/30/Android%20Touch%20%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E9%80%92%E4%B8%8E%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>一、MotionEvent</p><p>MotionEvent 是 Android 系统中报告动作输入（如触摸屏幕，滚动球，鼠标）等事件的类。其中有整形数的 Action 和描述事件的各种浮点型坐标。MotionEvent 的 action 的最低一个字节，其取值我们常见的 ACTION_DOWN, MOVE, POINTER_DOWN, POINTER_UP, UP, CANCEL (后面可能简称为 DOWN 等等) 这些了。虽然我们可能会粗暴的使用下面这样的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">    <span class="keyword">case</span> MotionEvent.ActionDown:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是其实上面这样仅适用于单点触控场景，原因是 getAction() 方法返回的结果中，最低的1个字节才对应上面说的 ACTION_DOWN，而次最低一个字节则表示 PointerIndex (这个概念后面会提到)，对于单点触控场景，PointerIndex 始终为0，所以上面的代码才能跑通。更好的方式，其实是使用 getActionMasked() 方法，此处查看源码即可非常清晰。</p><p>对于一串触摸事件（指手接触到屏幕到手完全离开屏幕），用户第一个手指接触到屏幕时，触发 DOWN, 手指在屏幕上移动时，持续触发出很多 MOVE，第二个以上的手指触摸到屏幕是，触发 POINTER_DOWN，非最后一个离开屏幕的手指离开屏幕时触发 POINTER_UP, 最后一个手指离开屏幕时，触发 UP。</p><p>在一串触摸事件过程中，视图从 window detach 的话，或者 View 的 PFLAG_CANCEL_NEXT_UP_EVENT 标记位设置了时，或者 View 本来处理了一个 Down 事件但是接下来的 MOVE 等事件被 ViewGroup 拦截了，将会触发 CANCEL。当然，应该还有别的触发 CANCEL 事件的场景。下图是一串 Touch 事件的例子：</p><pre><code>Down → Move →...→ Move → PointerDown → Move →...→ PointerUp → Move →...→ Move → Up</code></pre><p>MotionEvent 中有个 Pointer 的概念，Pointer 大致表示触摸到屏幕的各个手指。getPointerCount() 即为多点触控的点数。每个 pointer 都有一个 index (取值是0到getPointerCount()-1)和 id（最大是31，意味着一串触摸事件中，最多允许手指接触屏幕32次），前者在一串 Touch 事件中可能会变化，而后者保持不变，例如多点触控时，大拇指对应的 index 本来是0，后面可能变成了1了. getPointerId(int pointerIndex)和findPointerIndex(int pointerId)这两个方法是 index 和 id 间的一一映射。 那为什么要有 index 和 id 两个东西呢？</p><p>index 和 id 的区别。举个例子就清楚了。假设起始时，右手的食指，中指，无名指依次先后落在屏幕上，那么三个指头的 index 和 id 分别都是 0, 1, 2。此时抬起中指，那么食指的 index 和 id 不变，而无名指的 index 变成1，id 依然是2。即 index 总是 0, 1, 2,…, getPointerCount() - 1. 而 id 则可能大于 getPointerCount(), 另一面则是，pointer 的 id 在整个一串触摸事件中保持不变。</p><p>MotionEvent 的 getX() 与 getX(int pointerIndex), 前者等价于后者的 getX(0), getY 类似. getPointerIdBits() 返回一个类似于标志数的东西，其二进制从右向左数，第 i 位为1表示存在 id 是 i 的 pointer，此处应看源码。可以想见此结果的二进制形式中1的个数即为多点触控的点数。</p><p><img src="http://tao93.top/images/2018/09/01/1535807958.png" alt="pointer_id_bits"></p><p>二、Touch 事件的生成</p><p>Touch 事件的根源是从硬件而来，而 ViewRootImpl$ViewPostImeInputStage#processPointerEvent 方法是一个比较合适的开始追踪 Touch 事件的起点，此处应看源码。事件如果没有被消费，最终可能将在 ViewRootImpl #finishInputEvent 中回收掉(这不是本文的重点)。Touch 事件的传递堆栈 (按调用的顺序排列)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ViewRootImpl$ViewPostImeInputStage#processPointerEvent</span><br><span class="line">View#dispatchPointerEvent</span><br><span class="line">DecorView#dispatchTouchEvent</span><br><span class="line">Activity#dispatchTouchEvent</span><br><span class="line">PhoneWindow#superDispatchTouchEvent</span><br><span class="line">DecorView#superDispatchTouchEvent</span><br><span class="line">ViewGroup#dispatchTouchEvent</span><br></pre></td></tr></table></figure><p>Touch 事件传递到了 ViewGroup 的 dispatchTouchEvent 方法后，就开始是本文要关注的焦点了，即一串 Touch 事件在 View 树上是如何传递和消费的。</p><p>三、传递和处理 Touch 事件</p><p>下面是事件传递和处理中最重要的 4 个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">View#dispatchTouchEvent，非 ViewGroup 的 View 接受 Touch 事件的方法，我们一般不重载它。</span><br><span class="line"></span><br><span class="line">View#onTouchEvent，View(含 ViewGroup)自己尝试去消费 Touch 事件，经常会被重载。</span><br><span class="line"></span><br><span class="line">ViewGroup#dispatchTouchEvent，重载了 View 的同名方法，作为 ViewGroup 接受 Touch 事件，此方法中包含「传递 Touch 事件给 child」和「尝试自己消费 Touch 事件」这样两个分支逻辑，一般不重载它。</span><br><span class="line"></span><br><span class="line">ViewGroup#onInterceptTouchEvent，ViewGroup 判断自己要不要拦截 Touch 事件的方法，拦截意味着自己尝试消费此事件，有时候被重载。</span><br></pre></td></tr></table></figure><p><strong>传递:</strong></p><p>在 View 树中，Touch 事件是由 parent view 传递给 child View (child view 也可能是 ViewGroup)的。在一串 touch 事件中打头的总是 DOWN 事件，parent view 通过调用 child view 的 dispatchTouchEvent方法把 DOWN 事件传递给 child view，这就给了 child 一个消费此事件的机会。child 的 dispatchTouchEvent 方法返回 true 的话，就表示 child 消费了 DOWN 事件，返回 false 就表示不消费。如果 child 消费了 Down 事件，那么最简单的情况就是后续的 move 等事件都会通过调用 child 的 dispatchTouchEvent 方法直接交给此 child，不管它的 dispatchTouchEvent 方法返回什么；如果 child 没有消费 DOWN 事件，那么单点触控情形下，后续的 move 等事件与此 child 再也无缘了。</p><p><strong>消费：</strong></p><p>View(包括 ViewGroup) 消费 Touch 事件，在代码上等价于调用当前类的 onTouchEvent 方法。然后 ouTouchEvent 的返回结果作为是否消费了此事件的依据。</p><p><strong>拦截：</strong></p><p>拦截是指 ViewGroup 有机会在把 touch 事件 dispatch 给 child 前，通过调用自己的 onInterceptTouchEvent 来判断要不要把 touch 事件截下来给自己尝试消费。对于 DOWN 事件，onInterceptTouchEvent 总是会被调用；对于其他事件，child 有机会在 parent 的onInterceptTouchEvent 被调用之前，请求 parent 不要拦截，这个请求就是通过 child 调用 parent 的 requestDisallowInterceptTouchEvent 方法来实现的。</p><p><strong>DOWN 事件：</strong></p><p>DOWN 事件是一串 touch 事件的第一个事件，在 ViewGroup 的 dispatchTouchEvent 方法中，接到此事件时，首先会做一些清除工作，然后检查自己要不要拦截此事件和是不是要转为 CANCEL 事件。如果不拦截且不转为 CANCEL，那么挨个检查 child，在恰当的时候调用 child 的 dispatchTouchEvent 来看有没有 child 会消费此事件。</p><p>上面 4 段话，用伪代码来表示，大概就是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewGroup</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted; <span class="comment">// 拦截即不把事件传给 child </span></span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>; <span class="comment">// View group 是否消费了事件 </span></span><br><span class="line">        <span class="keyword">if</span> (is DOWN || child ever comsumed previous event) &#123; </span><br><span class="line">            <span class="keyword">if</span> (! disallowIntercept) &#123; <span class="comment">// PS: 对于 DOWN 其实 disallowIntercept 一定是 false </span></span><br><span class="line">                intercepted = onInterceptTouchEvent(event); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                intercepted = <span class="keyword">false</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            intercepted = <span class="keyword">true</span>; </span><br><span class="line">        &#125; <span class="keyword">if</span> (! canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">            <span class="keyword">for</span> (View child : all children) &#123;</span><br><span class="line">                <span class="keyword">if</span> (! child able to consume event) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>; </span><br><span class="line">                &#125; <span class="keyword">if</span> (dispatchTransformedTouchEvent(event, child)) &#123; </span><br><span class="line">                    <span class="comment">// 做一些记录工作，然后 break </span></span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// previous event 指这一串 touch 事件中在 event 前面的那些 </span></span><br><span class="line">        <span class="keyword">if</span> (no child ever consumed previous event) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTransformedTouchEvent(event); </span><br><span class="line">            <span class="comment">// 尝试自行消费 event </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">// 其实非 down 事件才能走到这个 else 分支 </span></span><br><span class="line">            <span class="keyword">for</span> (child : children who has consumed previous event) &#123;</span><br><span class="line">                <span class="keyword">if</span> (child.dispatchTouchEvent(event) </span><br><span class="line">                    handled = <span class="keyword">true</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> handled; </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>; </span><br><span class="line">        <span class="keyword">if</span> (mOnTouchListener != <span class="keyword">null</span> &amp;&amp; isEnabled &amp;&amp; mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123; </span><br><span class="line">            result = <span class="keyword">true</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// onTouch 优于 onTouchEvent 来代表 View 尝试消费 event </span></span><br><span class="line">        <span class="keyword">if</span> (! result &amp;&amp; onTouchEvent(event)) &#123; </span><br><span class="line">            result = <span class="keyword">true</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> result; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isEnabled()) &#123;</span><br><span class="line">            <span class="keyword">return</span> isClickable() || isLongClickable(); </span><br><span class="line">        &#125; <span class="keyword">if</span> (isClickable || isLongClickable) &#123; </span><br><span class="line">            ...</span><br><span class="line">            retrun <span class="keyword">true</span>; </span><br><span class="line">        &#125; retrun <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各个类和方法的角色描述如下：</p><blockquote><p>ViewGroup#dispatchTouchEvent，代表 ViewGroup 接受事件，处理拦截逻辑，尝试分发事件给 child，调用 View#dispatchTouchEvent来尝试自行消费 Touch 事件。返回值表示自己这颗子树有没有消费事件。</p></blockquote><blockquote><p>View#dispatchTouchEvent 代表非 ViewGroup 的 View 接受事件，调用真正尝试消费事件的代码（onTouchEvent 或者 onTouch 之类的方法）。返回值表示自己有没有消费事件。</p></blockquote><blockquote><p>ViewGroup#onInterceptTouchEvent，返回值表示 ViewGroup 要不要拦截事件。</p></blockquote><blockquote><p>ViewGroup#requestDisallowIntercept，被 child 来调用，表示请求 parent 不要拦截，这个请求仅在非 DOWN 事件有效，且会递归向上调用所有 parent 的同名方法。</p></blockquote><blockquote><p>TouchTarget 类，此类包含消费过 Touch 事件的 child 和它消费过哪些 pointer 的事件这些信息，TouchTarget 如下图所示。在 ViewGroup 中，存有一个 TouchTarget 链表，遍历此链表，即可知道一个 pointer 是否已有事件被某个 child 处理过。</p></blockquote><p>以上的介绍，其实是省略了不少信息，真正的事件分发过程，要更复杂不少，下面是我尝试画的一张流程图 (把图和源码对照着理解可能会有些帮助)：</p><p><img src="http://tao93.top/images/2018/09/01/1535809116.png" alt=""></p><p>对于上图，有一些需要解释的地方：</p><ol><li><p>TouchTarget 持有一个 child View，和此 child View 曾消费过 Down 或者 pointerDown 事件的那些 Pointer 的 id，这些 pointer id 是以 id bits 的形式存储为一个整数的。</p></li><li><p>TouchTarget 链表的头结点是由 mFirstTouchTarget 引用的。在一串事件结束(处理完 UP)后，正常情况链表应该清空，在一串 Touch 事件到来前(处理 Down 前)也会清空，算是补刀。</p></li><li><p>链表的意义是，存储 child 曾经消费过某些 pointer 的 Down 或者 PointerDown 事件这种信息。当一个 Pointer 结束了（手指头离开屏幕），那么所有消费过它的 Down 或者 PointerDown 事件的 TouchTarget 都需要移除掉它的 id，事实上，这一串 touch 事件中再也不会有这个 id 了；如果一个 TouchTarget 的 pointer id移除光了，那么意味着此 TouchTarget 持有的 child 没有消费过任意(现存)的 pointer 的 Down 或者 PointerDown，于是可以把此 TouchTarget 从链表移除了。</p></li><li><p>每次一个 Down 或者 PointerDown 事件 ev 到来时，对于 ViewGroup 的每个 child x，若 ev 的坐标落在 x 的范围内(否则就 continue，考虑下一个 child)，进一步「如果 x 在链表中(说明 x 消费过 Down 或者 pointerDown 事件)，那么 x 就是要被分发的 child；否则如果 x.dispatchTouchEvent(ev) 返回 true 了，那么 x 同样是要被分发的 child，虽然此时分发已经结束了」。</p></li><li><p>每个 move 事件 ev 到来时，链表为空的话，显然没有 child 消费过 down 或者 pointerDown，那么直接让 viewGroup 处理 ev 就好了。链表不为空的话，对于链表的每个 TouchTarget t 持有的 child x：如果转成了 cancel 事件，那么向 x 分发一个 cancel 事件，另外把 t 从链表移除(移除的原因是，例如 x 正在 detaching，所以才引发 cancel，那么当然需要把持有 x 的 t 移除)，然后 over，即 move 事件丢失了；没转成 cancel，那就检查 t 的 idBits 中有没有 ev 的任意一个 pointer 的 id，有则把 ev 交给 x，没有则 continue。</p></li></ol><p>四、源码分析</p><p>下面粘贴一大段加上了我的理解作为注释的源码，代码真的很长很长，这还仅仅是 ViewGroup#dispatchTouchEvent 这一个方法的代码。关于多点触控的处理逻辑，我也没有彻底明白，sigh。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 若当前类上面覆盖了其他window, 且 ev 的flag已标记过滤「覆盖」情况下的事件，则直接跳过</span></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line">        <span class="comment">// Handle an initial down.</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">            <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class="line">            <span class="comment">// due to an app switch, ANR, or some other state change.</span></span><br><span class="line">            cancelAndClearTouchTargets(ev); <span class="comment">//如链表非空, 向其中所有 touchTarget 持有的 child 发 cancel 事件, 并清空链表</span></span><br><span class="line">            resetTouchState(); <span class="comment">// reset 此 ViewGroup 的 CANCEL_NEXT_UP 和 DISALLOW_INTERCEPT</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check for interception.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">        <span class="comment">// down 事件, 或者链表不空(意思是曾有 down 事件被某个 child 消费过)时, 考虑拦截</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 前面的 resetTouchState() 使得 disallowIntercept 必定是 false</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 其他情况, 不用把事件交给任何 child, 所以直接赋值 intercepted = true</span></span><br><span class="line">            <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">            <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">            intercepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check for cancelation.</span></span><br><span class="line">        <span class="comment">// 此 ViewGroup 有 cancel_next_up 标志, 那么就转成 cancel 事件</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>)</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line">        <span class="comment">// Update list of touch targets for pointer down, if needed.</span></span><br><span class="line">        <span class="comment">// API 11 以上, split 必为 true</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="number">0</span>;</span><br><span class="line">        TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 标记 down/pointerDown 被某个 child 消费</span></span><br><span class="line">        <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">            <span class="comment">// down/pointerDown 才寻求 child 来接盘, 其余类型的事件都是谁消费了 down/pointerDown 就交给谁</span></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                <span class="comment">// 得到 ev 当前 action 所所属的 pointer 的 index</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// always 0 for down</span></span><br><span class="line">                <span class="comment">// idBitsToAssign 包含一个 id, 即 ev 所属 pointer 的 id</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                        : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line">                <span class="comment">// Clean up earlier touch targets for this pointer id in case they</span></span><br><span class="line">                <span class="comment">// have become out of sync.</span></span><br><span class="line">                <span class="comment">// down/pointerDown 意味着新的 pointer, 清除一下链表中和新 pointer 的 id 之间的瓜葛</span></span><br><span class="line">                removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line">                    <span class="comment">// Find a child that can receive the event.</span></span><br><span class="line">                    <span class="comment">// Scan children from front to back.</span></span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">                    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                                childrenCount, i, customOrder);</span><br><span class="line">                        <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                                preorderedList, children, childIndex);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 不能接受或者是 ev 坐标不在 child 内部则 continue</span></span><br><span class="line">                        <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                                || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        newTouchTarget = getTouchTarget(child);</span><br><span class="line">                        <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 说明 ev 落在 child 内部且 child 以前响应过 down/pointerDown, 那么由 child 来接盘, 故 break</span></span><br><span class="line">                            <span class="comment">// 如果 ev 是 Down 事件, 列表尚空, 则走不到这里来</span></span><br><span class="line">                            <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">                            <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">                            <span class="comment">// child 所属 TouchTarget 可能增加一个 pointer id</span></span><br><span class="line">                            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        resetCancelNextUpFlag(child);</span><br><span class="line">                        <span class="comment">// 尝试让 child 消费 ev</span></span><br><span class="line">                        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                            <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">                            mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                            <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                        mLastTouchDownIndex = j;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                mLastTouchDownIndex = childIndex;</span><br><span class="line">                            &#125;</span><br><span class="line">                            mLastTouchDownX = ev.getX();</span><br><span class="line">                            mLastTouchDownY = ev.getY();</span><br><span class="line">                            <span class="comment">// 消费成功的话, 用 child 新建 TouchTarget, 插到链表头部,</span></span><br><span class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                            alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// The accessibility focus didn't handle the event, so clear</span></span><br><span class="line">                        <span class="comment">// the flag and do a normal dispatch to all children.</span></span><br><span class="line">                        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 没找到接盘的, 且链表不空(意思是有 Down/pointerDown 被 child View 消费过)</span></span><br><span class="line">                    <span class="comment">// Did not find a child to receive the event.</span></span><br><span class="line">                    <span class="comment">// Assign the pointer to the least recently added target.</span></span><br><span class="line">                    <span class="comment">// 强行让链表末尾节点持有的 child 来接盘</span></span><br><span class="line">                    newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                    <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        newTouchTarget = newTouchTarget.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Dispatch to touch targets.</span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123; <span class="comment">// child view 压根没有消费过事件</span></span><br><span class="line">            <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">            <span class="comment">// view group 尝试自行消费</span></span><br><span class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                    TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Dispatch to touch targets, excluding the new touch target if we already</span></span><br><span class="line">            <span class="comment">// dispatched to it.  Cancel touch targets if necessary.</span></span><br><span class="line">            TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">            TouchTarget target = mFirstTouchTarget;</span><br><span class="line">            <span class="comment">// 遍历链表</span></span><br><span class="line">            <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                    <span class="comment">// ev 是 Down 或者 pointer Down 且它被 target 持有的 child 消费了</span></span><br><span class="line">                    handled = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 对于其他的 Touch target</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                            || intercepted;</span><br><span class="line">                    <span class="comment">// 发送 cancel 或者 ev 给 child, 或者啥也不做(target 的 idBits 没有 ev 中任意的 pointer 的 id)</span></span><br><span class="line">                    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                            target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                        handled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (cancelChild) &#123; <span class="comment">// 收到 cancel 后,child 就不该再收到事件了, 对应的 TouchTarget 也要移除</span></span><br><span class="line">                        <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            mFirstTouchTarget = next;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            predecessor.next = next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        target.recycle();</span><br><span class="line">                        target = next;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                predecessor = target;</span><br><span class="line">                target = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Update list of touch targets for pointer up or cancel, if needed.</span></span><br><span class="line">        <span class="keyword">if</span> (canceled</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">            resetTouchState(); <span class="comment">// up 事件后,这一串 Touch 事件就结束了, 清理链表等</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">            <span class="comment">// 某个 pointer 没了, 那么清空链表中和这个 pointer 的瓜葛</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> idBitsToRemove = <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">            removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!handled &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(ev, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>五、滑动冲突分析示例</p><p>在《安卓开发艺术探索》一书中讲 touch 事件的最后，讲了滑动冲突的解决方法。所谓滑动冲突最简单的情形就是一个水平滑动的 ScrollView 里面放一个竖直滑动的 listView，两者滑动方向不同，即为滑动冲突。对于这个情形，解决滑动冲突，其实就是在手指上下滑时吧 move 事件给 child（listView）处理，而手指左右滑动时给 parent 处理（ScrollView）即可。下面是书中的一种解决方式，使用上面讲的知识，我们可以透彻的分析这种解决方式。</p><p>下面是《安卓开发艺术探索》中提供的其中一种解决方法，我加入了比较详细的注释作为解释，在前面的基础上，这种解决方法的逻辑就很明确了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildView</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">view</span>.<span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        ViewParent parent = getParent();</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (event.getActionMasked()) &#123;</span><br><span class="line">                <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                    <span class="comment">// 此次请求其实在 Down 事件后的首个 Move 传至 parent 中时生效</span></span><br><span class="line">                    <span class="comment">// 若不请求，则将会发生拦截，后续事件都和 child 无缘，所以必须请求别拦截</span></span><br><span class="line">                    parent.requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                    <span class="comment">// 如果期望 parent 来处理，那么解除请求，则下一次 Move 事件时必定拦截，后续事件就全部交给 parent 了。</span></span><br><span class="line">                    <span class="comment">// 否则，什么也不做，即事件会继续源源不断的交给 child</span></span><br><span class="line">                    <span class="keyword">if</span> (parent should handle event)&#123;</span><br><span class="line">                        parent.requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentView</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Down 时，必然调此方法，此时不应拦截，否则 child 永远无法处理 move 事件</span></span><br><span class="line">        <span class="comment">// 其他事件时，若 child 请求不拦截，那么后面的事件都交给 child 了；否则，就会</span></span><br><span class="line">        <span class="comment">// 调用此方法，此方法这时返回 True 即表示拦截，那么会发一个 cancel 给 child，后续的事件就和 child 无缘了</span></span><br><span class="line">        <span class="keyword">return</span> ev.getActionMasked() != MotionEvent.ACTION_DOWN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，这篇长长的、并不完美的分析也就结束了。</p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android ImageView ScaleType</title>
      <link href="/2018/08/30/Android%20ImageView%20ScaleType/"/>
      <url>/2018/08/30/Android%20ImageView%20ScaleType/</url>
      <content type="html"><![CDATA[<p>我经常记不住 Android 中 ImageView 的各种 ScaleType 的含义，看文档一时也确定不了，所以干脆把所有 ScaleType 挨个尝试了一遍，然后清楚的记录下来，以备今后查阅。</p><p><strong>CEMTER</strong></p><p>图片大小不做任何缩放，仅仅把图片中心和视图中心重合。可能图片小于视图框，也可能反过来。</p><p><strong>CENTER_CROP</strong></p><p>将图片放大或者缩小，直到视图框被布满，且图片的两个边缘或者所有边缘和视图框的对应边缘重合。</p><p><strong>CENTER_INSIDE</strong></p><p>可能将图片缩小，但是不会放大，目标是把图片放置在视图框之内，不能有露在外面的，图片中心和视图框中心重合。</p><p><strong>FIT_CENTER</strong></p><p>图片可能放大也可能缩小，目标是让图片在是图框内部，且图片占据最大的可用空间，图片中心和视图框中心重合。</p><p><strong>FIT_START</strong></p><p>类似于 fit_center 只不过图片中心可能和视图框中心不重合，而是图片处在视图框的上侧或者左侧。</p><p><strong>FIT_END</strong></p><p>类似于 fit_center 只不过图片中心可能和视图框中心不重合，而是图片处在视图框的下侧或者右侧。</p><p><strong>FIT_XY</strong></p><p>图片可能会被拉伸，效果是图片的四个边缘和视图框的四个边缘无条件重合。</p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL 数据库支持 emoji 表情字符</title>
      <link href="/2018/08/30/MySQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%AF%E6%8C%81%20emoji%20%E8%A1%A8%E6%83%85%E5%AD%97%E7%AC%A6/"/>
      <url>/2018/08/30/MySQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%AF%E6%8C%81%20emoji%20%E8%A1%A8%E6%83%85%E5%AD%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<p>兴冲冲的整个博客，死皮赖脸的叫几个同学来评论，结果评论中输入的 emoji 表情最后会变成问号，试想别人评论「写的真棒 😄」结果变成了「写的真棒 ？」，这是何其的尴尬。</p><p>继续回到这个问题本身。我登录到数据库一查，发现数据库中存的评论文本就是个问号，这说明 emoji 表情存到数据库的过程出问题了。赶紧一查，发现网上还是很容易找到了解决方法。问题的原因是 MySQL 存储文本时默认的 UTF-8 仅支持 3 个字节编码，而 emoji 是 4 字节编码的，所以存储过程出问题了。所以需要将 charset 设置为 UTF-8 的超集 UTF-8mb4，虽然我也不知道这个 UTF-8mb4 是何方神圣。</p><p>首先，需要在配置文件 my.cnf (在我的机器上这个文件路径是 /etc/my.cnf) 中添加一下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">character-set-client-handshake = FALSE</span><br><span class="line">character-set-server = utf8mb4</span><br><span class="line">collation-server = utf8mb4_unicode_ci</span><br><span class="line">init_connect=’SET NAMES utf8mb4&apos;</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8mb4</span><br></pre></td></tr></table></figure><p>然后，需要修改已有库、表、字段的 charset。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 修改库的 </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> &lt;database_name&gt; <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8mb4 <span class="keyword">COLLATE</span> = utf8mb4_unicode_ci; </span><br><span class="line"></span><br><span class="line"># 修改表的 </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;table_name&gt; <span class="keyword">CONVERT</span> <span class="keyword">TO</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci; </span><br><span class="line"></span><br><span class="line"># 修改字段的 </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;table_name&gt; <span class="keyword">CHANGE</span> &lt;column_name&gt; &lt;column_name&gt; &lt;original_column_type&gt; <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p>最后重新启动 MySQL 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/mysql stop sudo /etc/init.d/mysql start</span><br></pre></td></tr></table></figure><p>另外，mysqldump 时，也需要进行额外指定 char set：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -default-character-set-utf8mb4 -u &lt;db_user_name&gt; -p --databases &lt;db_name&gt; --lock-all-tables &gt; &lt;file_name&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用的 Bash 命令总结</title>
      <link href="/2018/08/30/%E5%B8%B8%E7%94%A8%E7%9A%84%20Bash%20%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/30/%E5%B8%B8%E7%94%A8%E7%9A%84%20Bash%20%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>这篇记录是我看 <a href="http://linuxcommand.org/tlcl.php" target="_blank" rel="noopener">The Linux Command Line</a> 后为了总结而写的，目的是便于自己随时查阅。The Linux Command Line 是我相当喜欢的一本电子书，它是一本值得一页一页看下去的书。</p><p><strong>cp</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅复制目标目录不存在或者存在但是更旧的的项。 </span></span><br><span class="line">cp -u </span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 file2 已经存在, file2 的内容会被 file1 的内容重写。如果 file2 不存在，则会创建它。 </span></span><br><span class="line">cp file1 file2 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果目录 dir2 不存在，创建目录 dir2，操作完成后，目录 dir2 中的内容和 dir1 中的一样。如果目录 dir2 存在，则目录 dir1 和其中的内容将会被复制到 dir2 中。 </span></span><br><span class="line">cp -r dir1 dir2</span><br></pre></td></tr></table></figure><p><strong>mv</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅移动目标目录不存在或者存在但是更旧的的项。 </span></span><br><span class="line">mv -u </span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果目录 dir2 不存在，创建目录 dir2，并且移动目录 dir1 的内容到目录 dir2 中，同时删除目录 dir1。如果目录 dir2 存在，移动目录 dir1( 它的内容)到目录 dir2 中。 </span></span><br><span class="line">mv dir1 dir2</span><br></pre></td></tr></table></figure><p><strong>rm</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 警惕不小心写出 rm * .html 这样的命令，这会删除当前目录的所有文件。</span><br></pre></td></tr></table></figure><p><strong>命令的4中形式</strong></p><ol><li>executable file, 可以是二进制的，也可以是文本形式的脚本；</li><li>builtins, 即 /bin 下面的 [, echo, kill, pwd, test 和 /usr/bin 下面的 alias, bg, cd, command, false, fc, fg, getopts, hash, jobs, printf, read, true, type, ulimit, umask, unalias, wait, which；</li><li>shell 函数</li><li>alias 定义的别名</li></ol><p><strong>type</strong></p><p>type是一个极其有用的命令，能立马找到当前环境能用的命令是源自哪里，是什么类型的。示例：</p><blockquote><p>➜  ~ type Python3<br>Python3 is /Users/didi/.bin/Python3<br>➜  ~ ls -l /Users/didi/.bin/Python3<br>lrwxr-xr-x  1 didi  staff  22  4 25 10:06 /Users/didi/.bin/Python3 -&gt; /usr/local/bin/python3<br>➜  ~ type [<br>[ is a shell builtin<br>➜  ~ type ls<br>ls is an alias for ls -G</p></blockquote><p><strong>where</strong></p><p>where命令的有用之处是它可以列出所有出现的地方，比如电脑里面有两个 git 可执行文件，那么 where git 可以把它们统统列出来。</p><p><strong>man 手册的章节含义</strong></p><ol><li>用户命令</li><li>程序接口内核系统调用</li><li>库函数程序接口</li><li>特殊文件，比如说设备结点和驱动程序</li><li>文件格式</li><li>游戏娱乐，如屏幕保护程序</li><li>其他方面</li><li>系统管理员命令</li></ol><p><strong>&gt; file_name</strong></p><p>巧妙的使用重定向，可以将文本文件的内容清空，也可以新建一个空文件。</p><p><strong>重定向的常见用法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 覆盖型重定向 stdout，可以省略那个 1 </span></span><br><span class="line">ls ~ 1&gt; out.txt </span><br><span class="line"></span><br><span class="line"><span class="comment"># 追加性重定向 stdout，可以省略那个 1 </span></span><br><span class="line">ls ~ 1&gt;&gt; out.txt </span><br><span class="line"></span><br><span class="line"><span class="comment"># 覆盖型重定向 stderr </span></span><br><span class="line">ls ~ 2&gt; out.txt </span><br><span class="line"></span><br><span class="line"><span class="comment"># 追加性重定向 stdout </span></span><br><span class="line">ls ~ 2&gt;&gt; out.txt</span><br></pre></td></tr></table></figure><p><strong>/dev/null</strong></p><p>随意放东西进去的垃圾箱</p><p><strong>花括号展开</strong></p><p>echo Front-{A..D}–Back 将会输出四项内容，即 {A..D} 表示从 A 到 D 一共四个情况。</p><p><strong>将命令执行结果展开</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只需要把命令放在 $() 里面即可，旧版 shell 也使用把命令放在 `` 中间的方式 </span></span><br><span class="line"><span class="built_in">echo</span> $(ls)</span><br></pre></td></tr></table></figure><p><strong>引号</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 双引号中，参数展开，算术表达式展开，和命令替换仍然有效，比如 </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$USER</span> <span class="variable">$((2+2)</span>) <span class="variable">$(cal)</span>"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 单引号中，所有展开都无效</span></span><br></pre></td></tr></table></figure><p><strong>命令行移动光标</strong></p><blockquote><p>ctrl a # 移动到行首</p><p>ctrl e # 移动到行末</p><p>alt &lt;- # 左移一个 word</p><p>alt -&gt; # 右移一个 word</p><p>ctrl u # 剪切整行内容</p><p>ctrl k # 剪切光标后面的内容</p><p>ctrl y # 粘贴</p></blockquote><p><strong>管理进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出终端相关进程</span></span><br><span class="line">ps </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有进程</span></span><br><span class="line">ps x </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有进程的详细信息</span></span><br><span class="line">ps aux </span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示从终端启动的后台进程</span></span><br><span class="line"><span class="built_in">jobs</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 让指定序号的从终端启动的进程返回到前台</span></span><br><span class="line"><span class="built_in">fg</span> %JOB_SPEC </span><br><span class="line"></span><br><span class="line"><span class="comment"># 让指定序号的从终端启动的进程返回到后台</span></span><br><span class="line"><span class="built_in">bg</span> %JOB_SPEC </span><br><span class="line"></span><br><span class="line"><span class="comment"># 给进程发送信号，最常见的信号是：</span></span><br><span class="line"><span class="built_in">kill</span> -SIG_NUM PID </span><br><span class="line">    1  HUP  挂起</span><br><span class="line">    2  INT  中断，和 ctrl c 的作用一样</span><br><span class="line">    9  KILL 杀死，这个信号并不会发给进程号是 PID 的进程，而是立即强制停止此进程，被杀进程就没有机会保存数据</span><br><span class="line">    15 TERM <span class="built_in">kill</span> 命令的默认信号，终止进程，被中止的进程有机会保存数据</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Bash </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>

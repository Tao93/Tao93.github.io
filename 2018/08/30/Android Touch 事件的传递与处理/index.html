<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="A blog of Liu Tao"><title>Android Touch 事件的传递与处理 | Liu Tao</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android Touch 事件的传递与处理</h1><a id="logo" href="/.">Liu Tao</a><p class="description">A little older, a little wiser</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android Touch 事件的传递与处理</h1><div class="post-meta">Aug 30, 2018</div><div class="post-content"><p>一、MotionEvent</p>
<p>MotionEvent 是 Android 系统中报告动作输入（如触摸屏幕，滚动球，鼠标）等事件的类。其中有整形数的 Action 和描述事件的各种浮点型坐标。MotionEvent 的 action 的最低一个字节，其取值我们常见的 ACTION_DOWN, MOVE, POINTER_DOWN, POINTER_UP, UP, CANCEL (后面可能简称为 DOWN 等等) 这些了。虽然我们可能会粗暴的使用下面这样的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">    <span class="keyword">case</span> MotionEvent.ActionDown:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是其实上面这样仅适用于单点触控场景，原因是 getAction() 方法返回的结果中，最低的1个字节才对应上面说的 ACTION_DOWN，而次最低一个字节则表示 PointerIndex (这个概念后面会提到)，对于单点触控场景，PointerIndex 始终为0，所以上面的代码才能跑通。更好的方式，其实是使用 getActionMasked() 方法，此处查看源码即可非常清晰。</p>
<p>对于一串触摸事件（指手接触到屏幕到手完全离开屏幕），用户第一个手指接触到屏幕时，触发 DOWN, 手指在屏幕上移动时，持续触发出很多 MOVE，第二个以上的手指触摸到屏幕是，触发 POINTER_DOWN，非最后一个离开屏幕的手指离开屏幕时触发 POINTER_UP, 最后一个手指离开屏幕时，触发 UP。</p>
<p>在一串触摸事件过程中，视图从 window detach 的话，或者 View 的 PFLAG_CANCEL_NEXT_UP_EVENT 标记位设置了时，或者 View 本来处理了一个 Down 事件但是接下来的 MOVE 等事件被 ViewGroup 拦截了，将会触发 CANCEL。当然，应该还有别的触发 CANCEL 事件的场景。下图是一串 Touch 事件的例子：</p>
<pre><code>Down → Move →...→ Move → PointerDown → Move →...→ PointerUp → Move →...→ Move → Up
</code></pre><p>MotionEvent 中有个 Pointer 的概念，Pointer 大致表示触摸到屏幕的各个手指。getPointerCount() 即为多点触控的点数。每个 pointer 都有一个 index (取值是0到getPointerCount()-1)和 id（最大是31，意味着一串触摸事件中，最多允许手指接触屏幕32次），前者在一串 Touch 事件中可能会变化，而后者保持不变，例如多点触控时，大拇指对应的 index 本来是0，后面可能变成了1了. getPointerId(int pointerIndex)和findPointerIndex(int pointerId)这两个方法是 index 和 id 间的一一映射。 那为什么要有 index 和 id 两个东西呢？</p>
<p>index 和 id 的区别。举个例子就清楚了。假设起始时，右手的食指，中指，无名指依次先后落在屏幕上，那么三个指头的 index 和 id 分别都是 0, 1, 2。此时抬起中指，那么食指的 index 和 id 不变，而无名指的 index 变成1，id 依然是2。即 index 总是 0, 1, 2,…, getPointerCount() - 1. 而 id 则可能大于 getPointerCount(), 另一面则是，pointer 的 id 在整个一串触摸事件中保持不变。</p>
<p>MotionEvent 的 getX() 与 getX(int pointerIndex), 前者等价于后者的 getX(0), getY 类似. getPointerIdBits() 返回一个类似于标志数的东西，其二进制从右向左数，第 i 位为1表示存在 id 是 i 的 pointer，此处应看源码。可以想见此结果的二进制形式中1的个数即为多点触控的点数。</p>
<p><img src="https://tao93.top/images/2018/09/01/1535807958.png" alt="pointer_id_bits"></p>
<p>二、Touch 事件的生成</p>
<p>Touch 事件的根源是从硬件而来，而 ViewRootImpl$ViewPostImeInputStage#processPointerEvent 方法是一个比较合适的开始追踪 Touch 事件的起点，此处应看源码。事件如果没有被消费，最终可能将在 ViewRootImpl #finishInputEvent 中回收掉(这不是本文的重点)。Touch 事件的传递堆栈 (按调用的顺序排列)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ViewRootImpl$ViewPostImeInputStage#processPointerEvent</span><br><span class="line">View#dispatchPointerEvent</span><br><span class="line">DecorView#dispatchTouchEvent</span><br><span class="line">Activity#dispatchTouchEvent</span><br><span class="line">PhoneWindow#superDispatchTouchEvent</span><br><span class="line">DecorView#superDispatchTouchEvent</span><br><span class="line">ViewGroup#dispatchTouchEvent</span><br></pre></td></tr></table></figure>
<p>Touch 事件传递到了 ViewGroup 的 dispatchTouchEvent 方法后，就开始是本文要关注的焦点了，即一串 Touch 事件在 View 树上是如何传递和消费的。</p>
<p>三、传递和处理 Touch 事件</p>
<p>下面是事件传递和处理中最重要的 4 个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">View#dispatchTouchEvent，非 ViewGroup 的 View 接受 Touch 事件的方法，我们一般不重载它。</span><br><span class="line"></span><br><span class="line">View#onTouchEvent，View(含 ViewGroup)自己尝试去消费 Touch 事件，经常会被重载。</span><br><span class="line"></span><br><span class="line">ViewGroup#dispatchTouchEvent，重载了 View 的同名方法，作为 ViewGroup 接受 Touch 事件，此方法中包含「传递 Touch 事件给 child」和「尝试自己消费 Touch 事件」这样两个分支逻辑，一般不重载它。</span><br><span class="line"></span><br><span class="line">ViewGroup#onInterceptTouchEvent，ViewGroup 判断自己要不要拦截 Touch 事件的方法，拦截意味着自己尝试消费此事件，有时候被重载。</span><br></pre></td></tr></table></figure>
<p><strong>传递:</strong></p>
<p>在 View 树中，Touch 事件是由 parent view 传递给 child View (child view 也可能是 ViewGroup)的。在一串 touch 事件中打头的总是 DOWN 事件，parent view 通过调用 child view 的 dispatchTouchEvent方法把 DOWN 事件传递给 child view，这就给了 child 一个消费此事件的机会。child 的 dispatchTouchEvent 方法返回 true 的话，就表示 child 消费了 DOWN 事件，返回 false 就表示不消费。如果 child 消费了 Down 事件，那么最简单的情况就是后续的 move 等事件都会通过调用 child 的 dispatchTouchEvent 方法直接交给此 child，不管它的 dispatchTouchEvent 方法返回什么；如果 child 没有消费 DOWN 事件，那么单点触控情形下，后续的 move 等事件与此 child 再也无缘了。</p>
<p><strong>消费：</strong></p>
<p>View(包括 ViewGroup) 消费 Touch 事件，在代码上等价于调用当前类的 onTouchEvent 方法。然后 ouTouchEvent 的返回结果作为是否消费了此事件的依据。</p>
<p><strong>拦截：</strong></p>
<p>拦截是指 ViewGroup 有机会在把 touch 事件 dispatch 给 child 前，通过调用自己的 onInterceptTouchEvent 来判断要不要把 touch 事件截下来给自己尝试消费。对于 DOWN 事件，onInterceptTouchEvent 总是会被调用；对于其他事件，child 有机会在 parent 的onInterceptTouchEvent 被调用之前，请求 parent 不要拦截，这个请求就是通过 child 调用 parent 的 requestDisallowInterceptTouchEvent 方法来实现的。</p>
<p><strong>DOWN 事件：</strong></p>
<p>DOWN 事件是一串 touch 事件的第一个事件，在 ViewGroup 的 dispatchTouchEvent 方法中，接到此事件时，首先会做一些清除工作，然后检查自己要不要拦截此事件和是不是要转为 CANCEL 事件。如果不拦截且不转为 CANCEL，那么挨个检查 child，在恰当的时候调用 child 的 dispatchTouchEvent 来看有没有 child 会消费此事件。</p>
<p>上面 4 段话，用伪代码来表示，大概就是下面这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewGroup</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted; <span class="comment">// 拦截即不把事件传给 child </span></span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>; <span class="comment">// View group 是否消费了事件 </span></span><br><span class="line">        <span class="keyword">if</span> (is DOWN || child ever comsumed previous event) &#123; </span><br><span class="line">            <span class="keyword">if</span> (! disallowIntercept) &#123; <span class="comment">// PS: 对于 DOWN 其实 disallowIntercept 一定是 false </span></span><br><span class="line">                intercepted = onInterceptTouchEvent(event); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                intercepted = <span class="keyword">false</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            intercepted = <span class="keyword">true</span>; </span><br><span class="line">        &#125; <span class="keyword">if</span> (! canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">            <span class="keyword">for</span> (View child : all children) &#123;</span><br><span class="line">                <span class="keyword">if</span> (! child able to consume event) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>; </span><br><span class="line">                &#125; <span class="keyword">if</span> (dispatchTransformedTouchEvent(event, child)) &#123; </span><br><span class="line">                    <span class="comment">// 做一些记录工作，然后 break </span></span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// previous event 指这一串 touch 事件中在 event 前面的那些 </span></span><br><span class="line">        <span class="keyword">if</span> (no child ever consumed previous event) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTransformedTouchEvent(event); </span><br><span class="line">            <span class="comment">// 尝试自行消费 event </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">// 其实非 down 事件才能走到这个 else 分支 </span></span><br><span class="line">            <span class="keyword">for</span> (child : children who has consumed previous event) &#123;</span><br><span class="line">                <span class="keyword">if</span> (child.dispatchTouchEvent(event) </span><br><span class="line">                    handled = <span class="keyword">true</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> handled; </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>; </span><br><span class="line">        <span class="keyword">if</span> (mOnTouchListener != <span class="keyword">null</span> &amp;&amp; isEnabled &amp;&amp; mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123; </span><br><span class="line">            result = <span class="keyword">true</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// onTouch 优于 onTouchEvent 来代表 View 尝试消费 event </span></span><br><span class="line">        <span class="keyword">if</span> (! result &amp;&amp; onTouchEvent(event)) &#123; </span><br><span class="line">            result = <span class="keyword">true</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> result; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isEnabled()) &#123;</span><br><span class="line">            <span class="keyword">return</span> isClickable() || isLongClickable(); </span><br><span class="line">        &#125; <span class="keyword">if</span> (isClickable || isLongClickable) &#123; </span><br><span class="line">            ...</span><br><span class="line">            retrun <span class="keyword">true</span>; </span><br><span class="line">        &#125; retrun <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>各个类和方法的角色描述如下：</p>
<blockquote>
<p>ViewGroup#dispatchTouchEvent，代表 ViewGroup 接受事件，处理拦截逻辑，尝试分发事件给 child，调用 View#dispatchTouchEvent来尝试自行消费 Touch 事件。返回值表示自己这颗子树有没有消费事件。</p>
</blockquote>
<blockquote>
<p>View#dispatchTouchEvent 代表非 ViewGroup 的 View 接受事件，调用真正尝试消费事件的代码（onTouchEvent 或者 onTouch 之类的方法）。返回值表示自己有没有消费事件。</p>
</blockquote>
<blockquote>
<p>ViewGroup#onInterceptTouchEvent，返回值表示 ViewGroup 要不要拦截事件。</p>
</blockquote>
<blockquote>
<p>ViewGroup#requestDisallowIntercept，被 child 来调用，表示请求 parent 不要拦截，这个请求仅在非 DOWN 事件有效，且会递归向上调用所有 parent 的同名方法。</p>
</blockquote>
<blockquote>
<p>TouchTarget 类，此类包含消费过 Touch 事件的 child 和它消费过哪些 pointer 的事件这些信息，TouchTarget 如下图所示。在 ViewGroup 中，存有一个 TouchTarget 链表，遍历此链表，即可知道一个 pointer 是否已有事件被某个 child 处理过。</p>
</blockquote>
<p>以上的介绍，其实是省略了不少信息，真正的事件分发过程，要更复杂不少，下面是我尝试画的一张流程图 (把图和源码对照着理解可能会有些帮助)：</p>
<p><img src="https://tao93.top/images/2018/09/01/1535809116.png" alt=""></p>
<p>对于上图，有一些需要解释的地方：</p>
<ol>
<li><p>TouchTarget 持有一个 child View，和此 child View 曾消费过 Down 或者 pointerDown 事件的那些 Pointer 的 id，这些 pointer id 是以 id bits 的形式存储为一个整数的。</p>
</li>
<li><p>TouchTarget 链表的头结点是由 mFirstTouchTarget 引用的。在一串事件结束(处理完 UP)后，正常情况链表应该清空，在一串 Touch 事件到来前(处理 Down 前)也会清空，算是补刀。</p>
</li>
<li><p>链表的意义是，存储 child 曾经消费过某些 pointer 的 Down 或者 PointerDown 事件这种信息。当一个 Pointer 结束了（手指头离开屏幕），那么所有消费过它的 Down 或者 PointerDown 事件的 TouchTarget 都需要移除掉它的 id，事实上，这一串 touch 事件中再也不会有这个 id 了；如果一个 TouchTarget 的 pointer id移除光了，那么意味着此 TouchTarget 持有的 child 没有消费过任意(现存)的 pointer 的 Down 或者 PointerDown，于是可以把此 TouchTarget 从链表移除了。</p>
</li>
<li><p>每次一个 Down 或者 PointerDown 事件 ev 到来时，对于 ViewGroup 的每个 child x，若 ev 的坐标落在 x 的范围内(否则就 continue，考虑下一个 child)，进一步「如果 x 在链表中(说明 x 消费过 Down 或者 pointerDown 事件)，那么 x 就是要被分发的 child；否则如果 x.dispatchTouchEvent(ev) 返回 true 了，那么 x 同样是要被分发的 child，虽然此时分发已经结束了」。</p>
</li>
<li><p>每个 move 事件 ev 到来时，链表为空的话，显然没有 child 消费过 down 或者 pointerDown，那么直接让 viewGroup 处理 ev 就好了。链表不为空的话，对于链表的每个 TouchTarget t 持有的 child x：如果转成了 cancel 事件，那么向 x 分发一个 cancel 事件，另外把 t 从链表移除(移除的原因是，例如 x 正在 detaching，所以才引发 cancel，那么当然需要把持有 x 的 t 移除)，然后 over，即 move 事件丢失了；没转成 cancel，那就检查 t 的 idBits 中有没有 ev 的任意一个 pointer 的 id，有则把 ev 交给 x，没有则 continue。</p>
</li>
</ol>
<p>四、源码分析</p>
<p>下面粘贴一大段加上了我的理解作为注释的源码，代码真的很长很长，这还仅仅是 ViewGroup#dispatchTouchEvent 这一个方法的代码。关于多点触控的处理逻辑，我也没有彻底明白，sigh。。。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 若当前类上面覆盖了其他window, 且 ev 的flag已标记过滤「覆盖」情况下的事件，则直接跳过</span></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line">        <span class="comment">// Handle an initial down.</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">            <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class="line">            <span class="comment">// due to an app switch, ANR, or some other state change.</span></span><br><span class="line">            cancelAndClearTouchTargets(ev); <span class="comment">//如链表非空, 向其中所有 touchTarget 持有的 child 发 cancel 事件, 并清空链表</span></span><br><span class="line">            resetTouchState(); <span class="comment">// reset 此 ViewGroup 的 CANCEL_NEXT_UP 和 DISALLOW_INTERCEPT</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check for interception.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">        <span class="comment">// down 事件, 或者链表不空(意思是曾有 down 事件被某个 child 消费过)时, 考虑拦截</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 前面的 resetTouchState() 使得 disallowIntercept 必定是 false</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 其他情况, 不用把事件交给任何 child, 所以直接赋值 intercepted = true</span></span><br><span class="line">            <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">            <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">            intercepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check for cancelation.</span></span><br><span class="line">        <span class="comment">// 此 ViewGroup 有 cancel_next_up 标志, 那么就转成 cancel 事件</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>)</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line">        <span class="comment">// Update list of touch targets for pointer down, if needed.</span></span><br><span class="line">        <span class="comment">// API 11 以上, split 必为 true</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="number">0</span>;</span><br><span class="line">        TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 标记 down/pointerDown 被某个 child 消费</span></span><br><span class="line">        <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">            <span class="comment">// down/pointerDown 才寻求 child 来接盘, 其余类型的事件都是谁消费了 down/pointerDown 就交给谁</span></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                <span class="comment">// 得到 ev 当前 action 所所属的 pointer 的 index</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// always 0 for down</span></span><br><span class="line">                <span class="comment">// idBitsToAssign 包含一个 id, 即 ev 所属 pointer 的 id</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                        : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line">                <span class="comment">// Clean up earlier touch targets for this pointer id in case they</span></span><br><span class="line">                <span class="comment">// have become out of sync.</span></span><br><span class="line">                <span class="comment">// down/pointerDown 意味着新的 pointer, 清除一下链表中和新 pointer 的 id 之间的瓜葛</span></span><br><span class="line">                removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line">                    <span class="comment">// Find a child that can receive the event.</span></span><br><span class="line">                    <span class="comment">// Scan children from front to back.</span></span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">                    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                                childrenCount, i, customOrder);</span><br><span class="line">                        <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                                preorderedList, children, childIndex);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 不能接受或者是 ev 坐标不在 child 内部则 continue</span></span><br><span class="line">                        <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                                || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        newTouchTarget = getTouchTarget(child);</span><br><span class="line">                        <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 说明 ev 落在 child 内部且 child 以前响应过 down/pointerDown, 那么由 child 来接盘, 故 break</span></span><br><span class="line">                            <span class="comment">// 如果 ev 是 Down 事件, 列表尚空, 则走不到这里来</span></span><br><span class="line">                            <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">                            <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">                            <span class="comment">// child 所属 TouchTarget 可能增加一个 pointer id</span></span><br><span class="line">                            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        resetCancelNextUpFlag(child);</span><br><span class="line">                        <span class="comment">// 尝试让 child 消费 ev</span></span><br><span class="line">                        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                            <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">                            mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                            <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                        mLastTouchDownIndex = j;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                mLastTouchDownIndex = childIndex;</span><br><span class="line">                            &#125;</span><br><span class="line">                            mLastTouchDownX = ev.getX();</span><br><span class="line">                            mLastTouchDownY = ev.getY();</span><br><span class="line">                            <span class="comment">// 消费成功的话, 用 child 新建 TouchTarget, 插到链表头部,</span></span><br><span class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                            alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// The accessibility focus didn't handle the event, so clear</span></span><br><span class="line">                        <span class="comment">// the flag and do a normal dispatch to all children.</span></span><br><span class="line">                        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 没找到接盘的, 且链表不空(意思是有 Down/pointerDown 被 child View 消费过)</span></span><br><span class="line">                    <span class="comment">// Did not find a child to receive the event.</span></span><br><span class="line">                    <span class="comment">// Assign the pointer to the least recently added target.</span></span><br><span class="line">                    <span class="comment">// 强行让链表末尾节点持有的 child 来接盘</span></span><br><span class="line">                    newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                    <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        newTouchTarget = newTouchTarget.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Dispatch to touch targets.</span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123; <span class="comment">// child view 压根没有消费过事件</span></span><br><span class="line">            <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">            <span class="comment">// view group 尝试自行消费</span></span><br><span class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                    TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Dispatch to touch targets, excluding the new touch target if we already</span></span><br><span class="line">            <span class="comment">// dispatched to it.  Cancel touch targets if necessary.</span></span><br><span class="line">            TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">            TouchTarget target = mFirstTouchTarget;</span><br><span class="line">            <span class="comment">// 遍历链表</span></span><br><span class="line">            <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                    <span class="comment">// ev 是 Down 或者 pointer Down 且它被 target 持有的 child 消费了</span></span><br><span class="line">                    handled = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 对于其他的 Touch target</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                            || intercepted;</span><br><span class="line">                    <span class="comment">// 发送 cancel 或者 ev 给 child, 或者啥也不做(target 的 idBits 没有 ev 中任意的 pointer 的 id)</span></span><br><span class="line">                    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                            target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                        handled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (cancelChild) &#123; <span class="comment">// 收到 cancel 后,child 就不该再收到事件了, 对应的 TouchTarget 也要移除</span></span><br><span class="line">                        <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            mFirstTouchTarget = next;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            predecessor.next = next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        target.recycle();</span><br><span class="line">                        target = next;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                predecessor = target;</span><br><span class="line">                target = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Update list of touch targets for pointer up or cancel, if needed.</span></span><br><span class="line">        <span class="keyword">if</span> (canceled</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">            resetTouchState(); <span class="comment">// up 事件后,这一串 Touch 事件就结束了, 清理链表等</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">            <span class="comment">// 某个 pointer 没了, 那么清空链表中和这个 pointer 的瓜葛</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> idBitsToRemove = <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">            removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!handled &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(ev, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>五、滑动冲突分析示例</p>
<p>在《安卓开发艺术探索》一书中讲 touch 事件的最后，讲了滑动冲突的解决方法。所谓滑动冲突最简单的情形就是一个水平滑动的 ScrollView 里面放一个竖直滑动的 listView，两者滑动方向不同，即为滑动冲突。对于这个情形，解决滑动冲突，其实就是在手指上下滑时吧 move 事件给 child（listView）处理，而手指左右滑动时给 parent 处理（ScrollView）即可。下面是书中的一种解决方式，使用上面讲的知识，我们可以透彻的分析这种解决方式。</p>
<p>下面是《安卓开发艺术探索》中提供的其中一种解决方法，我加入了比较详细的注释作为解释，在前面的基础上，这种解决方法的逻辑就很明确了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildView</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">view</span>.<span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        ViewParent parent = getParent();</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (event.getActionMasked()) &#123;</span><br><span class="line">                <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                    <span class="comment">// 此次请求其实在 Down 事件后的首个 Move 传至 parent 中时生效</span></span><br><span class="line">                    <span class="comment">// 若不请求，则将会发生拦截，后续事件都和 child 无缘，所以必须请求别拦截</span></span><br><span class="line">                    parent.requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                    <span class="comment">// 如果期望 parent 来处理，那么解除请求，则下一次 Move 事件时必定拦截，后续事件就全部交给 parent 了。</span></span><br><span class="line">                    <span class="comment">// 否则，什么也不做，即事件会继续源源不断的交给 child</span></span><br><span class="line">                    <span class="keyword">if</span> (parent should handle event)&#123;</span><br><span class="line">                        parent.requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentView</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Down 时，必然调此方法，此时不应拦截，否则 child 永远无法处理 move 事件</span></span><br><span class="line">        <span class="comment">// 其他事件时，若 child 请求不拦截，那么后面的事件都交给 child 了；否则，就会</span></span><br><span class="line">        <span class="comment">// 调用此方法，此方法这时返回 True 即表示拦截，那么会发一个 cancel 给 child，后续的事件就和 child 无缘了</span></span><br><span class="line">        <span class="keyword">return</span> ev.getActionMasked() != MotionEvent.ACTION_DOWN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，这篇长长的、并不完美的分析也就结束了。</p>
</div><div class="tags"><a href="/tags/Android/">Android</a></div><div class="post-nav"><a class="pre" href="/2018/09/01/HomeBrew Cask 加快下载的脚本/">HomeBrew Cask 加快下载的脚本</a><a class="next" href="/2018/08/30/Android ImageView ScaleType/">Android ImageView ScaleType</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  owner: 'Tao93',
  repo: 'gitment_repo',
  oauth: {
    client_id: 'f3da13462f03a1096838',
    client_secret: '2075bbcd881736e7fe52d99b9e694a1824a281ce',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/macOS/" style="font-size: 15px;">macOS</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Homebrew/" style="font-size: 15px;">Homebrew</a> <a href="/tags/Shell/" style="font-size: 15px;">Shell</a> <a href="/tags/Bash/" style="font-size: 15px;">Bash</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Algorithm/" style="font-size: 15px;">Algorithm</a> <a href="/tags/Other/" style="font-size: 15px;">Other</a> <a href="/tags/AOSP/" style="font-size: 15px;">AOSP</a> <a href="/tags/VPS/" style="font-size: 15px;">VPS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/09/01/博客系统迁移记录/">博客系统迁移记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/01/记一次混淆问题导致的 bug/">记一次混淆问题导致的 bug</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/01/记一个简单的递归问题与解法/">记一个简单的递归问题与解法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/01/日常修 Bug/">日常修 Bug</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/01/提高开发效率的各种工具/">提高开发效率的各种工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/01/修车小能手上线/">修车小能手上线</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/01/从阿里云服务器到个人博客/">从阿里云服务器到个人博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/01/从 Android 中 Message 的 obj 无法跨进程传送自定义 Parcelable 说起/">从 Android 中 Message 的 obj 无法跨进程传送自定义 Parcelable 说起</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/01/Python 也能玩跳一跳小游戏/">Python 也能玩跳一跳小游戏</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/01/macOS 系统编译 Android 8.1.0 源码全过程/">macOS 系统编译 Android 8.1.0 源码全过程</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Liu Tao.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>